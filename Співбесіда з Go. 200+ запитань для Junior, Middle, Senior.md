# [Співбесіда з Go. 200+ запитань для Junior, Middle, Senior](https://dou.ua/lenta/articles/interview-questions-go-developer/)

## Junior

### Software engineering

**1. Які бувають області пам’яті програми? У чому їхні особливості та відмінності?**

Стек (Stack) це область пам'яті, де зберігаються локальні змінні та адреси повернення функцій. Стек працює за принципом (Last-In-First-Out, LIFO).

Куча (Heap) це область пам'яті, в якій зберігаються об'єкти, створені в програмі. Куча має динамічний розмір та керується операторами виділення та звільнення пам'яті.

Глобальна область (Global Area) це область пам'яті, в якій зберігаються глобальні змінні та функції.

Статична область (Static Area) це область пам'яті, в якій зберігаються статичні змінні та функції.

Константна область (Constant Area) це захищена від змін область пам'яті, в якій зберігаються константи, такі як рядки та числа.

**2. Розкажіть, що ви знаєте про HTTP-протокол, які складові частини запиту? Які статус-коди знаєте, які групи можна виділити?**

HTTP — це протокол передачі даних прикладного рівня, який використовується для передачі веб-сторінок, зображень, відео та інших даних між веб-клієнтом та веб-сервером.

HTTP-запит складається з трьох основних частин:

1. стартовий рядок ("Метод URI HTTP/Версія" для запиту та "HTTP/Версія Статус-код Опис" для відповіді);  
2. заголовки;  
3. тіло повідомлення, що містить дані запиту, запитаний ресурс або опис проблеми, якщо запит не виконано.

Коди статусу:

- 1хх — інформаційний: запит прийнятий, продовжуй процес.
- 2хх — успіх: дія була успішно передана, зрозуміла, та прийнята.
- 3хх — перенаправлення: наступні дії мають бути успішно виконані для реалізації запиту.
- 4хх — помилка клієнта: запит містить синтаксичні помилки або не може бути виконаний.
- 5хх — помилка сервера: сервер не зміг виконати правильно сформований запит.

Найбільш поширені статуси:

- 200 OK — запит виконано успішно.
- 301 Moved Permanently — ресурс переміщено.
- 403 Forbidden — доступ до запитаного ресурсу заборонений.
- 404 Not Found — ресурс не знайдений.
- 503 Service Unavailable — сервіс недоступний.

Методи:

OPTIONS — Повертає методи HTTP, які підтримуються сервером. Цей метод може служити для визначення можливостей вебсервера.

GET — Запитує вміст вказаного ресурсу. Запитаний ресурс може приймати параметри, які передаються в рядку URI. Згідно зі стандартом HTTP, запити типу GET вважаються ідемпотентними — багаторазове повторення одного і того ж запиту GET повинне приводити до однакових результатів (за умови, що сам ресурс не змінився за час між запитами). Це дозволяє кешувати відповіді на запити GET. Якщо назва ресурсу не вказана (у URI наявні лише схема та доменне ім'я), то вебсервер повертає індекс директорії вебсервера.

HEAD — Аналогічний методу GET, за винятком того, що у відповіді сервера відсутнє тіло. Це корисно для витягання метаінформації, заданої в заголовках відповіді, без пересилання всього вмісту. Зокрема, клієнт чи проксі, перевіривши заголовок Last-Modified: (останній час модифікації), таким чином може переконатися, що сторінка на сервері не змінилася від часу попереднього запиту.

POST — Передає призначені для користувача дані (наприклад, з HTML-форми) заданому ресурсу. Наприклад, в блогах відвідувачі зазвичай можуть вводити свої коментарі до записів в HTML-форму, після чого вони передаються серверу методом POST, і він поміщає їх на сторінку. При цьому передані дані (у прикладі з блогами — текст коментаря) включаються в Тіло запиту (Request body). На відміну від методу GET, метод POST не вважається ідемпотентним, тобто багаторазове повторення одних і тих же запитів POST може повертати різні результати (наприклад, після кожного відправлення коментаря з'являтиметься одна копія цього коментаря).

PUT — Завантажує вказаний ресурс на сервер.

PATCH — Завантажує певну частину ресурсу на сервер.

DELETE — Видаляє вказаний ресурс.

TRACE — Повертає отриманий запит так, що клієнт може побачити, що проміжні сервери додають або змінюють в запиті.

CONNECT — Для використання разом з проксі-серверами, які можуть динамічно перемикатися в тунельний режим SSL.

**3. Назвіть та опишіть будь-який патерн програмування (на ваш вибір). Коли його доцільно використовувати та чому?**

**4. Що таке процеси та потоки в операційній системі? Опишіть їхній взаємозв’язок у контексті виконання програми.**

Процес — завантажена в пам'ять і готова до виконання програма, яка складається з коду, даних і інших системних ресурсів, таких як відкриті файли та канали.

Потік (thread) — базовий об'єкт, якому операційна система розподіляє час центрального процесора.

Виконання процесу починається зі стартового потоку. Надалі він може породжувати інші потоки. Ресурси процесу доступні всім його потокам. Кожен потік використовує структуру даних, для збереження контексту виконання, у той час, коли в нього віднімається процесор. У контекст входять регістри процесора, перемінні оточення, стеки ядра і користувача. Усі потоки одного процесу спільно використовують його віртуальний адресний простір.

Процесорний час розподіляється по черзі між потоками, а не між процесами.

**5. Що таке шаблон проєктування (design pattern)?**

[Шаблони проєктування](https://uk.wikipedia.org/wiki/Шаблони_проєктування_програмного_забезпечення) — ефективні способи вирішення задач проєктування програмного забезпечення. Об'єктно-орієнтований шаблон найчастіше є зразком вирішення проблеми і відображає відношення між класами та об'єктами, без вказівки на те, як буде зрештою реалізоване це відношення.

Типи шаблонів «Банди чотирьох» (Gang of Four, GOF — Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides), опубліковані в 1991 р. в книзі «Design Patterns — Elements of Reusable Object-Oriented Software»:

- Основні шаблони
- [Твірні шаблони](https://uk.wikipedia.org/wiki/%D0%A2%D0%B2%D1%96%D1%80%D0%BD%D1%96_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8)
([Abstract Factory](https://uk.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Builder](https://uk.wikipedia.org/wiki/%D0%91%D1%83%D0%B4%D1%96%D0%B2%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Dependency Injection](https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9),
[Singleton](https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Prototype](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Factory Method](https://uk.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Resource Acquisition Is Initialization](https://uk.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization),
[Lazy initialization](https://uk.wikipedia.org/wiki/%D0%9B%D1%96%D0%BD%D0%B8%D0%B2%D0%B0_%D1%96%D0%BD%D1%96%D1%86%D1%96%D0%B0%D0%BB%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F),
[Object pool](https://uk.wikipedia.org/wiki/%D0%9F%D1%83%D0%BB_%D0%BE%D0%B1%27%D1%94%D0%BA%D1%82%D1%96%D0%B2_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Multiton pattern](https://uk.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D1%82%D0%BE%D0%BD_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)))
- [Структурні шаблони](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%96_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8)
([Adapter](https://uk.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Decorator](https://uk.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Proxy](https://uk.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%96%D1%81%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Composite](https://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D1%83%D0%B2%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Bridge](https://uk.wikipedia.org/wiki/%D0%9C%D1%96%D1%81%D1%82_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Flyweight](https://uk.wikipedia.org/wiki/%D0%9B%D0%B5%D0%B3%D0%BA%D0%BE%D0%B2%D0%B0%D0%B3%D0%BE%D0%B2%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Facade](https://uk.wikipedia.org/wiki/%D0%A4%D0%B0%D1%81%D0%B0%D0%B4_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Module](https://uk.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\))
- [Шаблони поведінки](https://uk.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D1%96%D0%BD%D0%BA%D0%B8)
([Visitor](https://uk.wikipedia.org/wiki/%D0%92%D1%96%D0%B4%D0%B2%D1%96%D0%B4%D1%83%D0%B2%D0%B0%D1%87_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Interpreter](https://uk.wikipedia.org/wiki/%D0%86%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Iterator](https://uk.wikipedia.org/wiki/%D0%86%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Command](https://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Chain of Responsibility](https://uk.wikipedia.org/wiki/%D0%9B%D0%B0%D0%BD%D1%86%D1%8E%D0%B6%D0%BE%D0%BA_%D0%B2%D1%96%D0%B4%D0%BF%D0%BE%D0%B2%D1%96%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9),
[Mediator](https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Front controller](https://uk.wikipedia.org/wiki/Front_controller),
[Observer](https://uk.wikipedia.org/wiki/%D0%A1%D0%BF%D0%BE%D1%81%D1%82%D0%B5%D1%80%D1%96%D0%B3%D0%B0%D1%87_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[State](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BD_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Strategy](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D1%96%D1%8F_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Memento](https://uk.wikipedia.org/wiki/%D0%97%D0%BD%D1%96%D0%BC%D0%BE%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Template Method](https://uk.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)))
- [Шаблони паралельних операцій (конкурентного програмування)](https://uk.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82%D0%B5%D1%80%D0%BD%D0%B8_%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
([Active Object](https://en.wikipedia.org/wiki/Active_Object),
[Balking pattern](https://en.wikipedia.org/wiki/Balking_pattern),
[Barrier](https://en.wikipedia.org/wiki/Barrier_\(computer_science\)),
[Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking),
[Guarded suspension](https://en.wikipedia.org/wiki/Guarded_suspension),
[Leaders/followers pattern](https://java-design-patterns.com/patterns/leader-followers/),
[Monitor Object](https://en.wikipedia.org/wiki/Monitor_\(synchronization\)),
[Nuclear computation](https://en.wikipedia.org/wiki/Nuclear_computation),
[Reactor pattern](https://en.wikipedia.org/wiki/Reactor_pattern),
[Readers write lock pattern](https://en.wikipedia.org/wiki/Read_write_lock_pattern),
[Scheduler pattern](https://en.wikipedia.org/wiki/Read_write_lock_pattern),
[Thread pool pattern](https://en.wikipedia.org/wiki/Thread_pool_pattern),
[Thread-local storage](https://en.wikipedia.org/wiki/Thread-local_storage))

Також існує інша група шаблонів проєктування, що отримала назву [GRASP](https://uk.wikipedia.org/wiki/GRASP) — General Responsibility Assignment Software Patterns. Опис цих шаблонів наводить Craig Larman у своїй книзі «Applying UML and Patterns»:

- Інформаційний експерт (Information Expert)
- Творець примірників класу (Creator)
- Низька зв'язаність (Low Coupling)
- Високе зчеплення (High Cohesion)
- Контролер (Controller)
- Поліморфізм (Polymorphism)
- Штучний (Pure Fabrication)
- Перенаправлення (Indirection)
- Стійкий до змін (Protected Variations)

Шаблони GRASP формулюють найбільш базові принципи розподілу обов'язків між типами.

**6. Які знаєте алгоритми сортування?**

Відомі алгоритми сортування:

За час O(n^2):

- [Сортування вибором](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B2%D0%B8%D0%B1%D0%BE%D1%80%D0%BE%D0%BC) — (Selection sort) — пошук найменшого або найбільшого елемента і переміщення його в початок або кінець впорядкованого списку.
- [Сортування вставкою](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%BE%D1%8E) (включенням, Insertion sort) — визначаємо місце, де поточний елемент повинен знаходитися в упорядкованому списку, і вставляємо його туди.
- [Сортування обміном](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BE%D0%B1%D0%BC%D1%96%D0%BD%D0%BE%D0%BC) (сортування бульбашкою, Bubble sort) — для кожної пари індексів проводиться обмін, якщо елементи розташовані не по порядку.
- Сортування методом бінарної вставки

За час O(n log n):

- [Плавне сортування](https://uk.wikipedia.org/wiki/%D0%9F%D0%BB%D0%B0%D0%B2%D0%BD%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) (Smoothsort)
- [Пірамідальне сортування](https://uk.wikipedia.org/wiki/%D0%9F%D1%96%D1%80%D0%B0%D0%BC%D1%96%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
- [Швидке сортування](https://uk.wikipedia.org/wiki/%D0%A8%D0%B2%D0%B8%D0%B4%D0%BA%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
- [Сортування злиттям](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%BB%D0%B8%D1%82%D1%82%D1%8F%D0%BC)
- [Timsort](https://uk.wikipedia.org/wiki/Timsort)

За час O(n):

- [Сортування підрахунком](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BF%D1%96%D0%B4%D1%80%D0%B0%D1%85%D1%83%D0%BD%D0%BA%D0%BE%D0%BC)
- [Сортування за розрядами](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0_%D1%80%D0%BE%D0%B7%D1%80%D1%8F%D0%B4%D0%B0%D0%BC%D0%B8)
- [Сортування комірками](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BA%D0%BE%D0%BC%D1%96%D1%80%D0%BA%D0%B0%D0%BC%D0%B8)

За час O(n log^2 n):

- [Сортування злиттям модифіковане](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%BB%D0%B8%D1%82%D1%82%D1%8F%D0%BC_%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D1%96%D0%BA%D0%BE%D0%B2%D0%B0%D0%BD%D0%B5)
- [Сортування Шелла](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%A8%D0%B5%D0%BB%D0%BB%D0%B0)

За час O(n n!):

- Сортування перестановкою
- [Випадкове сортування](https://uk.wikipedia.org/wiki/%D0%92%D0%B8%D0%BF%D0%B0%D0%B4%D0%BA%D0%BE%D0%B2%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)

**7. Що таке Big-O notation?**

Big-O (Нотація Ландау) — поширена математична нотація для формального запису асимптотичної поведінки функцій. Це міра того, як швидко буде сповільнюватись робота коду з ростом кількості вхідних даних.

**8. Які відмінності між unit-тестом та інтеграційним тестом?**

Модульний тест — це метод тестування, за допомогою якого тестуються окремі одиниці вихідного коду, щоб визначити, чи готові вони до використання. Це допомагає зменшити вартість виправлення помилок, оскільки помилки виявляються на ранніх фазах життєвого циклу розробки.

Це свого роду тестування White Box; його можна виконати в будь-який час; не перевіряє, чи правильно код працює із зовнішніми залежностями; зазвичай його виконує розробник; знайти помилки легко; обслуговування є дешевим.

Інтеграційний тест — це техніка тестування програмного забезпечення, коли окремі блоки програми об'єднуються та перевіряються як група. Тестові заглушки та тестові драйвери використовуються для сприяння інтеграційному тестуванню.

Це свого роду тестування «чорної скриньки»; зазвичай проводиться після модульного тестування та перед тестуванням системи; звертає увагу на інтеграцію між модулями; перевіряє, чи правильно код працює із зовнішніми залежностями; зазвичай його виконує тестова група; знайти помилки складно; обслуговування є дорогим.

**9. Що таке mock і для чого його використовують?**

Mock Object (Макет об'єкта) у об'єктно-орієнтованому програмуванні — це об'єкт, що імітує поведінку справжнього об'єкту контрольованими способами, тобто, реалізує інтерфейс справжнього об'єкту, але не має власної реальної функціональності. Програміст зазвичай створює макет об'єкта для тестування поведінки інших об'єктів.

Корисні, коли реальний об'єкт недоцільно або неможливо використати в модульному тесті, наприклад коли об'єкт:

- надає недетерміновані результати (наприклад, час або температуру);
- є сценарії, які важко створити або відтворити (наприклад, помилка в мережі);
- повільно працює (наприклад, повна база даних, яка повинна бути ініціалізована до початку тестування);
- ще не існує або може змінити поведінку;
- повинен включати в себе інформацію і методи виключно для цілей тестування (а не для реального використання).

**10. Що таке SDLC? Які етапи й навіщо вони потрібні?**

SDLC (Software development lifecycle, Життєвий цикл розробки програмного забезпечення) — це повний процес розробки програмного рішення від ідеї до створення, розгортання та обслуговування.

Це детальний і визначений план етапів, який розробники використовують для планування, створення, тестування, розгортання та підтримки програмного рішення і який допомагає створювати якісне програмне забезпечення, що відповідає вимогам клієнтів і завершується в рамках оцінки витрат і встановлених часових рамок.

Зазвичай він включає сім етапів:

1. Requirement Analysis (Аналіз вимог) — документуються функціональні та нефункціональні вимоги, створюється специфікація програмного забезпечення.
2. Planning (Планування) — вирішуються питання, як буде виконуватися розробка, хто буде виконувати завдання, які витрати.
3. Architectural Design (Дизайн системи) — визначаються елементи системи, рівень безпеки, процес обробки та збереження інформації, технології, які будуть використовуватися.
4. Software Development (Розробка) — на цьому етапі починає писатися код.
5. Testing (Тестування) — тестування та виправлення знайдених дефектів.
6. Deployment (Розгортання) — надання програмного забезпечення кінцевим користувачам.
7. Maintenance (Експлуатація та обслуговування) — технічна підтримка продукту, зворотній зв’язок з користувачами.

**11. Що таке SOLID?**

SOLID — це абревіатура, складена з перших літер п'яти базових принципів об'єктно-орієнтованого програмування та дизайну і запропонована Робертом Мартіном у статті 2000 року Design Principles and Design Patterns:

- **S**RP, Single responsibility principle ([Принцип єдиного обов'язку](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%94%D0%B4%D0%B8%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%BE%D0%B2%27%D1%8F%D0%B7%D0%BA%D1%83)): кожен об'єкт має виконувати лише один обов'язок.
- **O**CP, Open/closed principle ([Принцип відкритості/закритості](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B2%D1%96%D0%B4%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96/%D0%B7%D0%B0%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96)): програмні сутності повинні бути відкритими для розширення, але закритими для змін. Тобто, має бути спосіб змінювати поведінку програмних модулів без потреби змінювати їхній вихідний код (наприклад, через механізм динамічного або статичного поліморфізму).
- **L**SP, Liskov substitution principle ([Принцип підстановки Лісков](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D1%96%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%9B%D1%96%D1%81%D0%BA%D0%BE%D0%B2)): об'єкти в програмі можуть бути заміненими їхніми нащадками без зміни коду програми.
- **I**SP, Interface segregation principle ([Принцип розділення інтерфейсу](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%80%D0%BE%D0%B7%D0%B4%D1%96%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F_%D1%96%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%83)): багато спеціалізованих інтерфейсів краще за один універсальний. Інтерфейс може бути поділений на спеціалізовані ще на стадії проєктування, заради майбутньої гнучкості програмних компонентів.
- **D**IP, Dependency inversion principle ([Принцип інверсії залежностей](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%96%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D1%96%D1%97_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)): залежності всередині системи будуються на основі абстракцій, що не повинні залежати від деталей; навпаки, деталі мають залежати від абстракцій. Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.

Принципи SOLID використовують для дизайну та розробки таких програмних систем, які, з великою ймовірністю, зможуть тривалий час розвиватися, розширятися і підтримуватися.

**12. Що таке MVC?**

Модель–вигляд/представлення–контролер (MVC, Model-view-controller) — архітектурний шаблон, який використовується під час проєктування та розробки програмного забезпечення.

Цей шаблон передбачає поділ системи на три взаємопов'язані частини: модель даних, вигляд (інтерфейс користувача) та модуль керування.

![MVC](https://upload.wikimedia.org/wikipedia/uk/thumb/d/d0/%D0%94%D1%96%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%B2%D0%B7%D0%B0%D1%94%D0%BC%D0%BE%D0%B4%D1%96%D1%97_%D0%BC%D1%96%D0%B6_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%83_MVC.png/400px-%D0%94%D1%96%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%B2%D0%B7%D0%B0%D1%94%D0%BC%D0%BE%D0%B4%D1%96%D1%97_%D0%BC%D1%96%D0%B6_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%83_MVC.png "MVC")

Застосовується для відокремлення даних (моделі) від інтерфейсу користувача (вигляду) так, щоб зміни інтерфейсу користувача мінімально впливали на роботу з даними, а зміни в моделі даних могли здійснюватися без змін інтерфейсу користувача, що створює гнучкий дизайн програмного забезпечення, який повинен полегшувати подальші зміни чи розширення програм, а також надавати можливість повторного використання окремих компонентів програми.

Крім того використання цього шаблону у великих системах сприяє впорядкованості їхньої структури і робить їх більш зрозумілими за рахунок зменшення складності.

**13. Що таке DBMS? Яка різниця між СУБД та базою даних?**

DBMS (Database Management System, Система управління базами даних, СУБД) — набір взаємопов'язаних даних (база даних) і програм для доступу до цих даних. Надає можливості створення, збереження, оновлення та пошуку інформації в базах даних з контролем доступу до даних.

База даних — сукупність даних, організованих відповідно до концепції, яка описує характеристику цих даних і взаємозв'язки між їх елементами. В загальному випадку база даних містить схеми, таблиці, подання, збережені процедури та інші об'єкти. Дані у базі організовують відповідно до моделі організації даних. Таким чином, сучасна база даних, крім самих даних, містить їх опис та може містити засоби для їх обробки.

**14. Які бувають типи баз даних?**

[Типи баз даних](https://dou.ua/lenta/articles/types-of-databases/):

- Прості типи баз даних
  - Текстові файли (csv-файли, ini-файли)

      Інформація збирається в простих за структурою файлах різних форматів. Для поділу полів застосовують пробіли, табуляцію, коми, крапку з комою та двокрапку.

      Такі бази легко використовувати — для роботи із файлами вистачить звичайного текстового редактора. Зручно працювати з елементами, що передбачають конфігурацію: обліковими даними, налаштуваннями під’єднання до віддалених серверів та пристроїв, портами тощо.

      Однак у таких базах важко встановити зв’язок між компонентами даних. Крім того, вони підходять не для всіх типів інформації.
  - Ієрархічні бази даних (організація файлових систем, DNS та LDAP-з’єднання)

      Між збереженими об’єктами встановлюються зв’язки. Об’єкти поділяються на «пращурів» (основні класи чи категорії об’єктів) та «нащадків» (примірники цих класів чи категорій). При цьому кожен «нащадок» може мати не більше ніж одного «пращура». Графічним втіленням такої бази даних є деревоподібна структура.

      Відносини між об’єктами реалізовані як фізичні покажчики. Наприклад, у файловій системі шлях до папки або файлу будується з імен кореневих та вкладених каталогів. Ще однією особливістю є моделювання відносин вкладеності та підпорядкованості.

      Але ієрархічна організація не передбачає зв’язку «багато-до-багатьох», через що система зберігання даних досить обмежена — забезпечує повільний доступ до сегментів даних нижніх рівнів ієрархії та орієнтується суто на певні типи запитів.
  - Мережеві бази даних (IDMS)

      Технологія розширює функціональність ієрархічного підходу за допомогою моделювання складних відносин між об’єктами. Тут «нащадки» можуть мати більше, ніж одного «пращура», проте обмеження ієрархічного підходу зберігаються.

      Подаються не деревом, а загальним графом (сукупністю двох кінцевих множин).
- Реляційні бази даних (MySQL, MariaDB, PostgreSQL, SQLite)

    Дані формуються у таблиці з рядків та стовпців. У рядках наводяться відомості про об’єкти (значення властивостей), а стовпці є властивостями об’єктів (поля).

    Складні відносини об’єктів у реляційних БД моделюються за допомогою зовнішніх ключів — посилань на інші таблиці. Це дає змогу підходити до питання проєктування бази даних із позицій нормалізації — мінімізації надмірності при описі властивостей об’єктів.

    Запити в реляційних базах даних формують за допомогою структурованої мови SQL. Вона дозволяє робити вибірки, проводити агрегації та угруповання, змінювати та видаляти дані, модифікувати структуру БД (створювати таблиці, поля), керувати доступом користувачів до тих чи інших операцій тощо.
- Нереляційні бази даних
  - Документоорієнтовані (MongoDB, RethinkDB, CouchDB, DocumentDB)

      Дані зберігаються в структурованих форматах — XML, JSON, BSON. При цьому зберігається адресний доступ до даних за ключем. Вміст документа може мати різний набір властивостей.

      Ці бази даних добре підходять для швидкої розробки систем та сервісів, що працюють з по-різному структурованими даними. Вони легко масштабуються та змінюють структуру за потреби.
  - Ключ-значення (DynamoDB, Redis, Riak, LevelDB, Memcached)

      Дані зберігаються як словник, де покажчиком є ключ. Можливе зберігання та обробка різних за типом і змістом даних.

      Крім того, вони мають високу швидкість доступу даних завдяки адресному зберіганню.

      Такі бази даних легко масштабувати. Можна створити правила шардування (практика розділення рядків однієї таблиці на кілька різних таблиць) за певними ключами — наприклад, сесії користувачів різних сайтів зберігаються у різних сегментах БД.

      Оскільки підхід не передбачає жорсткої типізації та структуризації даних, контроль їхньої валідності, а також найменування ключів залишаються на відповідальності розробника.
  - Графові (Neo4J, JanusGraph, Dgraph, OrientDB)

      Призначені для моделювання складних відносин за допомогою теорії графів, де зв’язками виступають ребра графа, а самі об’єкти — це вузли чи вершини.

      Такий підхід може стати в пригоді під час аналізу профілів користувачів соціальних мереж. Один користувач підписаний на оновлення іншого, інший підписаний на певну спільноту і так далі.

      Також технологія може використовуватися для аналізу економічної активності контрагентів для виявлення різних схем шахрайства. Наприклад, можна відстежити використання певних рахунків, карт чи реквізитів контрагентів у різних операціях.

      Особливістю є висока продуктивність, оскільки обхід ребер і вершин значно швидший за аналіз безлічі зовнішніх і внутрішніх таблиць в реляційних БД.
  - Стовпчикові/колонкові (Cassandra, HBase, ClickHouse)

      Записи в таких базах зберігаються не рядками, а стовпцями (колонками). Замість таблиць тут використовуються колонкові сімейства. Вони містять ключі, які вказують на формат рядка запису інформації про об’єкт. Кожен рядок має свій набір властивостей, що дозволяє зберігати у межах однієї родини по-різному структуровані дані.

      Технологію активно використовують при побудові аналітичних систем та сервісів, що працюють з великими обсягами даних.

      З групуванням властивостей колонок при запиті індексується менший обсяг даних, що забезпечує високу швидкість його виконання.

      БД мають широкі можливості масштабування та модифікації структури — при додаванні нових колонок не доведеться їх жорстко формалізувати, як у випадку з реляційними базами.
  - Часових рядів (OpenTSDB, Prometheus, InfluxDB, TimescaleDB)

      Можна використовувати для відстеження історичної динаміки за низкою показників. Дані групуються за часовими мітками. Частіше орієнтовані на запис, ніж на побудову складних аналітичних запитів.

      Особливістю є те, що можливо обробляти постійний потік вхідних даних.

      Продуктивність залежить від обсягу інформації, що надходить, і кількості метрик, що відстежуються.
  - NewSQL (MemSQL, VoltDB, Spanner)

      Компроміс між масштабованістю та узгодженістю за збереження реляційного підходу.

      Особливостями є широкі можливості масштабування та велика продуктивність і доступність даних. Однак є високі вимоги до апаратних ресурсів розробників.

      Застосування має сенс за умови розробки продукту, який можна характеризувати як високонавантажену систему.
  - Багатомодельні (ArangoDB)

      Поєднують у собі кілька підходів до організації даних одночасно.

      Це дає функціональне розмаїття під час розробки систем з їх використанням, можливість в одному запиті працювати з даними, що є у різних типах баз, не порушуючи при цьому узгодженості, широкі можливості масштабування за допомогою легкої інтеграції нових моделей баз даних у чинну інфраструктуру проєкту.

**15. Що таке Docker?**

[Docker](https://uk.wikipedia.org/wiki/Docker) — інструментарій для управління ізольованими Linux-контейнерами, який доповнює інструментарій LXC більш високорівневим API, що дозволяє керувати контейнерами на рівні ізоляції окремих процесів.

Зокрема, Docker дозволяє не переймаючись вмістом контейнера запускати довільні процеси в режимі ізоляції і потім переносити і клонувати сформовані для даних процесів контейнери на інші сервери, беручи на себе всю роботу зі створення, обслуговування і підтримки контейнерів.

### Бази даних

**16. Опишіть ACID-властивості реляційних баз даних.**

[ACID](https://uk.wikipedia.org/wiki/ACID) (Atomicity, Consistency, Isolation, Durability) (атомарність, узгодженість, ізольованість, довговічність) — це набір властивостей, що гарантують надійну роботу бази даних. В контексті баз даних, послідовність операцій з базою даних, яка задовольняє властивостям ACID, можна розглядати як одну логічну операцію над даними. Така послідовність операцій називається транзакцією.

**Атомарність** гарантує, що жодна транзакція не буде виконана частково. Будуть або виконані всі операції, що беруть участь у транзакції, або не виконано жодної. Якщо протягом роботи однієї з операцій виникне помилка і операцію буде відхилено, то будуть відхилені також усі інші зміни, здійснені в межах транзакції.

**Узгодженість** гарантує перебування системи у несуперечливому стані до початку дії транзакції і по її завершенню. При цьому вона може перебувати в неузгодженому стані протягом виконання транзакції, проте ця неузгодженість не буде видимою за межами транзакції завдяки іншим властивостям — атомарності та ізольованості.

**Ізольованість** означає, що жодні проміжні зміни не будуть видимі за межами транзакції аж до її завершення. Питання ізоляції стає актуальним при одночасній роботі багатьох транзакцій з тими самими даними. За цією вимогою, якщо дві транзакції намагатимуться змінити одні й ті самі дані, то одну з них буде відхилено або призупинено до завершення другої

**Довговічність** гарантує, що незалежно від інших проблем після відновлення працездатності системи результати завершених транзакцій будуть збережені. Іншими словами, якщо користувач отримав повідомлення про успішне завершення транзакції, то він може бути впевнений, що дані будуть збережені та відновлені у випадку збоїв.

**17. Є таблиця в реляційній БД зі 100 тисячами рядків. SELECT-запит з такої таблиці триває час *t*. Як зміниться час запиту, якщо кількість рядків буде один мільйон? Які є варіанти, залежно від запиту/таблиці?**

Час виконання SELECT-запиту залежить від кількості рядків у таблиці, структури таблиці, наявності індексів та складності запиту. Варіанти оптимізації запитів можуть включати використання індексів, вибірку конкретних полів, уникнення використання функцій агрегування, наприклад, COUNT або AVG, та роботу з кешем запитів.

**18. Для чого використовують індекси в базах даних і завдяки чому (яким структурам даних) вони працюють?**

[Індекс](https://uk.wikipedia.org/wiki/%D0%86%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%96_%D0%B1%D0%B0%D0%B7%D0%B8_%D0%B4%D0%B0%D0%BD%D0%B8%D1%85) — це об'єкт бази даних, створений з метою підвищення ефективності виконання запитів. Таблиці в базі даних можуть мати велику кількість рядків, які зберігаються у довільному порядку, і їх пошук за заданим значенням шляхом послідовного перегляду таблиці рядок за рядком може займати багато часу. Індекс формується зі значень одного чи кількох стовпчиків таблиці і вказівників на відповідні рядки таблиці і, таким чином, дозволяє знаходити потрібний рядок за заданим значенням. Прискорення роботи з використанням індексів досягається в першу чергу за рахунок того, що індекс має структуру, що оптимізована для пошуку.

Індекси фізично можуть бути реалізовані різними структурами. Найчастіше вживані [двійкові дерева](https://uk.wikipedia.org/wiki/%D0%91%D1%96%D0%BD%D0%B0%D1%80%D0%BD%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) і [хеш-таблиці](https://uk.wikipedia.org/wiki/%D0%93%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8F).

**19. З якими NoSQL-базами даних працювали? Які їхні переваги над реляційними базами?**

Redis — це NoSQL-база даних, яка дозволяє зберігати дані у форматі ключ-значення у швидкодіючому оперативному кеші, підтримує широкий спектр структур даних, включаючи списки, множини, хеші та сортовані множини.

NoSQL-бази даних порівняно з реляційними базами даних мають високу продуктивність та швидкий доступ до даних завдяки використанню спрощеної моделі даних та оптимізованої архітектури, зазвичай працюють на дешевшому обладнанні, що може знизити загальні витрати на обслуговування бази даних, дозволяють легко масштабувати базу даних горизонтально, тобто додавати нові сервери, щоб збільшити її продуктивність, що забезпечує високу доступність та масштабованість даних, зазвичай забезпечують гнучкішу модель даних, що дозволяє зберігати та обробляти різнорідні дані без необхідності використовувати строгу схему даних, нереляційні дані, такі як графи, ключ-значення та документи, що дозволяє використовувати їх для широкого спектру завдань та застосувань.

### Go

**20. На вашу думку, у чому перевага Go перед іншими мовами?**

Висока продуктивність компільованих мов з легкістю написання коду, швидкістю розробки і захищеністю від помилок, властивих скриптовим мовам, вбудовані засоби для паралельних обчислень, багатониткове програмування та ефективна робота на багатоядерних системах, засоби віддаленого керування пакунками, швидке компілювання під різні платформи, навіть на застарілому обладнанні.

**21. Що таке горутини й навіщо вони?**

Горутина - це легковажний потік виконання, який запускається з допомогою ключового слова go і працює у контексті основної програми. Горутини дозволяють створювати багатопоточні програми зі спільною пам'яттю, при цьому не потрібно явно створювати або керувати потоками виконання, як у більшості інших мов програмування.

Основною перевагою горутин є ефективність роботи з багатопоточністю. Вони забезпечують легкий та швидкий доступ до спільної пам'яті та можуть бути запущені та зупинені відносно дешево, забезпечують розподілення завдань на різні потоки, що дозволяє підвищувати швидкодію програм, простоту роботи з асинхронними операціями.

**22. Що таке GOROOT і GOPATH?**

GOROOT і GOPATH це змінні середовища, які використовуються в інструментах командного рядка Go.

GOROOT - вказує на шлях до кореневої директорії Go. В цій директорії зазвичай міститься встановлена версія Go, а також інші важливі файли і бібліотеки.

GOPATH - вказує на шлях до робочої директорії Go. У цій директорії зберігаються ваші проекти Go, а також всі залежності (бібліотеки), які ви використовуєте для розробки проекту.

Одна з особливостей Go - це те, що вона має вбудований менеджер залежностей, який дозволяє легко керувати залежностями вашого проекту. При цьому, всі залежності зазвичай зберігаються в папці GOPATH/pkg/mod.

**23. Які типи даних використовуються в Go?**

У мові програмування Go доступні наступні типи даних:

Базові типи:

bool: логічний тип даних, має два значення - true і false.

Numeric types: включають в себе цілі числа (int8, int16, int32, int64, uint8, uint16, uint32, uint64, uintptr), число з плаваючою точкою (float32, float64) і комплексні числа (complex64, complex128).

string: відповідає текстовим рядкам.

Складені типи:

Масиви (arrays): фіксований розмір послідовності однотипних елементів.

Слайси (slices): динамічний масив, може змінювати розмір під час виконання програми.

Карти (maps): набір пар ключ-значення, де кожен ключ унікальний.

Структури (structs): колекція різнотипних полів, що можуть мати власні імена.

Інтерфейси (interfaces): тип, що описує набір методів, які має реалізувати будь-який конкретний тип даних.

Особливі типи:

Функції (functions): блок коду, який можна викликати з іншого місця в програмі.

Вказівники (pointers): змінна, що містить адресу в пам'яті іншої змінної.

Спеціальні типи:

Пустий тип (empty type): тип без значень, використовується в окремих випадках.

alias type: новий тип, який створюється на основі існуючого, з використанням ключового слова type.

**24. Що робить функція ``init()``? Наведіть приклади, де її варто використовувати. Наведіть приклади, коли варто уникати.**

Функція ``init()`` є спеціальною функцією, яка автоматично викликається системою перед запуском програми і зазвичай використовується для виконання початкових налаштувань, ініціалізації глобальних змінних, підключення до баз даних або інших сервісів, встановлення рівня журналювання тощо.

Функція ``init()`` може бути визначена в будь-якому пакеті, і викликатися в порядку, визначеному системою. Наприклад, якщо ми маємо пакет з декількома файлами, то ``init()`` викликається в порядку їх компіляції. Якщо у пакеті є кілька функцій ``init()``, то вони виконуються в порядку їх оголошення.

Використання функції ``init()`` може викликати непередбачуване поведінку, якщо код пакету викликається відповідно до порядку завантаження модулів. Також, якщо використання функції init() призводить до створення глобальних змінних, то може виникнути проблема з гонками даних.

Виклик залежних від зовнішніх ресурсів функцій у ``init()`` може призвести до непередбачуваної поведінки програми в разі недоступності цих ресурсів.

**25. Поясніть різницю між помилкою і панікою.**

**26. Як відловлювати паніки?**

**27. Як отримати теперішній час?**

**28. Що таке iota?**

**29. Яка різниця між слайсом і масивом?**

**30. З яких частин складається змінна типу slice?**

**31. Як працює append?**

**32. Що таке len і capacity в slice?**

**33. Що таке пакети?**

**34. Що таке інтерфейси і як вони працюють?**

**35. Для чого потрібні інтерфейси в Golang?**

**36. Що таке тип даних string?**

**37. Чим відрізняються лапки в Go (подвійні, одинарні, зворотні): ``""``,``''``, ``\`\```?**

**38. Що таке rune?**

**39. Чи може змінна типу string приймати nil-значення?**

**40. Чи можна повернути з функції кілька значень?**

**41. Що відбувається під час конкатенації рядків?**

**42. Як ефективно склеїти кілька рядків?**

**43. Як записати в файл?**

**44. Що таке структура?**

**45. Що буде, якщо викликати ``log.Fatal``?**

**46. Поясніть різницю між конкурентністю і паралельністю?**

**47. Як оголосити відкладений виклик?**

**48. Що таке канал? Які типи каналів ви знаєте? Для чого вони потрібні?**

**49. Яка різниця між буферизованим і небуферизованим каналами?**

**50. Що буде, якщо читати із закритого каналу? Що буде, якщо писати у закритий канал?**

**51. Як перевірити, що змінна типу map має збережене значення для певного ключа?**

**52. Які стандартні env-змінні в Go?**

**53. Яка різниця між value & pointer receiver?**

**54. Як зробити type assertion?**

**55. Як та навіщо робити type assertion?**

**56. Як написати benchmark?**

**57. В якому порядку виконуються кейси в select?**

### Практичні завдання

**58. Реалізувати алгоритм двійкового пошуку елемента у слайсі.**

```
package main

import "fmt"

func binarySearch(arr []int, key int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := low + (high-low)/2
        if arr[mid] == key {
            return mid
        } else if arr[mid] > key {
            high = mid - 1
        } else {
            low = mid + 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 3, 5, 7, 9, 11, 13}
    key := 7
    result := binarySearch(arr, key)
    if result == -1 {
        fmt.Printf("Елемент %d не знайдено у слайсі\n", key)
    } else {
        fmt.Printf("Елемент %d знайдено у позиції %d\n", key, result)
    }
}
```

**59. Є [код](https://play.golang.org/p/a-JIesxdCQ7). Що виведеться на екран? Що потрібно зробити, щоб побачити запропонований висновок Foo1 і Foo2?**

```
// start
// end

package main

import (
	"fmt"
)

func main() {
	fmt.Println("start")
	c := make(chan int)
	go Foo1(c)
	go Foo2(c)
	fmt.Println("end")
	<-c
	c <- 1
}

func Foo1(c chan int) {
	fmt.Println("foo1 begin")
	c <- 1
	fmt.Println("foo1 end")
}

func Foo2(c chan int) {
	fmt.Println("foo2 begin")
	<-c
	fmt.Println("foo2 end")
}
```

**60. Є [код](https://play.golang.org/p/6CiZvQp7r3t). Що виведеться на екран? Як вивести на екран літери?**

```
// 0 1 2

package main

import (
	"fmt"
)

func main() {
	arr := []string{"a", "b", "c"}

	for _, x := range arr {
		fmt.Println(x)
	}
}
```

**61. Поміняйте місцями значення двох змінних без тимчасової допоміжної змінної.**

```
package main

import "fmt"

func main() {
	a := 1
	b := 2
	fmt.Printf("a: %d, b: %d\n", a, b)
	a, b = b, a
	fmt.Printf("a: %d, b: %d\n", a, b)
}
```

**62. Оберніть slice у зворотному порядку.**

```
package main

import (
	"fmt"
)

func reverse(s []int) []int {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
	return s
}

func main() {
	s := []int{1, 2, 3, 4, 5}
	fmt.Println(s) // [1 2 3 4 5]
	s = reverse(s)
	fmt.Println(s) // [5 4 3 2 1]
}
```

**63. Перемістіть усі zero values у кінець масиву.**

```
package main

import (
	"fmt"
)

func moveZeroes(nums []int) {
	z := 0
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			nums[i], nums[z] = nums[z], nums[i]
			z++
		}
	}
}

func main() {
	nums := []int{0, 1, 0, 3, 12}
	moveZeroes(nums)
	fmt.Println(nums) // [1 3 12 0 0]
}
```

## Middle

### Software engineering

**1. У чому переваги та недоліки використання protobuf у порівнянні з JSON?**

**2. Назвіть деякі з принципів 12-factor-app. Для чого використовують graceful shutdown?**

**3. Що таке dependency injection? А dependency inversion?**

**4. У вас є ssh-доступ на Linux-сервер, де запущено вебсервер. З сервером періодично відбуваються незаплановані рестарти. Сервер записує логи у файли (розмір лог-файлу &gt; 10 Mb). Які *nix-команди ви можете використати, щоб проаналізувати проблему?**

**5. Як працює TLS handshake?**

**6. Яка різниця між TCP & UDP? В якій ситуації UPD краще?**

**7. Розкажіть у найдрібніших деталях, що відбувається, коли клієнт посилає запит на сервер, а сервер цей запит отримує.**

**8. Що таке Clean Architecture? Наведіть приклад.**

**9. Що таке оперативна пам’ять?**

**10. Як різниця між stack & heap?**

**11. Для чого потрібні Docker та Kubernetes?**

**12. Розкажіть про абстракції Kubernetes, з якими працювали?**

**13. Що таке Pod? Як він влаштований?**

**14. Розкажіть про Data structures: stack, queue, linked list, trie, balanced tree.**

### Бази даних

**15. Які шляхи пошуку повільних SELECT-запитів у RDBMS? Які способи пришвидшення таких запитів?**

**16. Що таке нормальні форми бази даних?**

**17. Що таке індекси? Які їхні недоліки?**

**18. Які структури даних можуть використовуватися в індексах баз даних? Як вони працюють?**

**19. Яка різниця між foreign & primary key?**

**20. Поняття міграції у контексті баз даних. У чому переваги підходу з міграціями?**

**21. Що таке реплікація даних? Які варіанти реплікації існують для баз, з якими ви працювали?**

**22. Яка різниця між SQL і NoSQL?**

**23. Які типи NoSQL баз даних ви знаєте? Наведіть приклади. Яка між ними різниця?**

**24. Що таке колонкова БД? Переваги та недоліки.**

**25. Що таке документоорієнтована БД? Переваги та недоліки.**

**26. Розкажіть про роботу з key-value базами даних (бажано з власного досвіду).**

**27. З якими типами даних Redis у вас є практичний досвід? Назвіть приклади, коли їх доцільно використовувати.**

### Go

**28. Якими бібліотеками Go ви користувалися для доступу до RDBMS? Які у них позитивні та негативні сторони?**

**29. Для чого використовують Context? Які є варіанти скасовування контекстів?**

**30. Якими способами можна виключити (приховати) поля структури при JSON-серіалізації?**

**31. Назвіть примітиви пакету sync стандартної бібліотеки. Яке призначення та приклади застосування ``sync.WaitGroup``?**

**32. Яка різниця між Mutex та RWMutex?**

**33. Які є способи зупинити N горутин, запущених одночасно (наприклад, worker pool)?**

**34. Що таке замикання функцій?**

**35. Поясніть різницю між switch і select?**

**36. Які є способи дістати дані з JSON?**

**37. Як у Go реалізовані конструкції циклів?**

**38. Як влаштований тип map?**

**39. Який порядок перебору map?**

**40. Що таке серіалізація? Де вона застосовується?**

**41. Чи можна використовувати nil для ініціалізації змінної?**

**42. Чи можна задати місткість map? Чи можна отримати місткість map?**

**43. Як дізнатися кількість символів у рядку?**

**44. Що таке кодогенерація і для чого вона потрібна?**

**45. Чим відрізняється goroutine від OS thread?**

**46. Як і для чого використовують ``io.Reader`` і ``io.Writer``?**

**47. Як перетворити ``[]io.ReadWriter`` на ``[]io.Reader``?**

**48. Як вказати головній горутині очікувати завершення роботи всіх робочих горутин?**

**49. Чи завжди буде швидше передача Pointer як аргументу функції?**

**50. Що таке варіативна змінна функції? Як працювати з цією змінною?**

**51. Як працювати з пакетом internal?**

**52. Як працює імпорт через крапочку і чому це погана практика?**

**53. Як працює імпорт через підкреслення?**

**54. Що таке ``defer()``?**

**55. Як працювати з goto?**

**56. Що таке ``reflect.DeepEqual()`` і ``reflect.TypeOf()``?**

**57. Як розпарсити час?**

**58. Як порівняти дві дати?**

**59. Що таке вказівник і як з ним працювати?**

**60. Як перевірити, чи змінна імплементує інтерфейс?**

**61. Що таке embedding?**

**62. Опишіть кроки процесу тестування.**

**63. Як писати тести? Що таке табличні тести?**

**64. Що таке memory leak? Які є способи його виявлення? Як його позбутися?**

**65. Що таке race condition? Які є способи його виявлення? Як його позбутися?**

### Практичні завдання

**67. Реалізувати перевірку на слова на анаграму. Написати тест і бенчмарк. Оцінити складність розробленого алгоритму.**

**68. Є [код](https://play.golang.org/p/-3o2gp3enIG). Що виведеться на екран? Чому?**

**69. Є [код](https://play.golang.org/p/qwC_nJNFdEy). Чи можна передбачити, що виведеться на екран? Чому?**

**70. Реалізуйте Stack (LIFO).**

**71. Реалізуйте linked list.**

**72. Задача про суму підмножини (Subset Sum Problem). Дано: множина позитивних цілих чисел і значення sum. Визначте, чи існує підмножина даної множини з сумою, яка дорівнює значенню sum.  **
``Input: set [] = { 3 , 34 , 4 , 12 , 5 , 2 }, sum = 9``  
``Output: True``

## Senior

### Software engineering

**1. Що таке процес і потік? Як вони пов’язані між собою? Чи мають різні процеси чи потоки доступу до однієї області пам’яті?**

**2. Які інструменти зазвичай використовують для збору метрик і логів? Як працює Prometheus?**

**3. Як працює docker під капотом?**

**4. Як працює load balancer під капотом?**

**5. Для чого потрібні черги?**

**6. Що таке CQRS?**

**7. Які архітектури програмного забезпечення ви знаєте?**

**8. Яка різниця між мікросервісами та монолітом? Які є переваги та недоліки?**

**9. Як побудувати міжсервісну транзакцію?**

**10. Що таке розподілені транзакції? Як реалізувати?**

**11. Які проблеми вирішує патерн Saga?**

**12. Як реалізувати аутентифікацію в мікросервісній архітектурі?**

**13. Що таке Event Sourcing?**

**14. Сформулюйте CAP-теорему.**

**15. Розкажіть про Raft Consensus Algorithm.**

**16. У чому різниця між імперативною і декларативною парадигмою програмування? Наведіть приклади мов.**

### Бази даних

**17. Для чого потрібні графові бази даних?**

**18. Якщо точкові дані прив’язані до часу, які бази даних варто використовувати для збереження цих даних?**

**19. Що таке Materialized View? У чому відмінність від звичайного View?**

**20. Що таке ACID? Прокоментуйте, як ACID реалізований в PostgreSQL.**

**21. Яка різниця між BASE та ACID?**

**22. Назвіть рівні ізоляції транзакцій?**

**23. Досвід оптимізації бази. Які інструменти використовували?**

**24. Що таке шардинг? Які види є?**

**25. Як працює master-slave реплікація?**

**26. Як працюють індекси? Як вибрати індекси в таблицях?**

**27. Розкажіть про optimistic та pessimistic locking.**

### Go

**28. За що відповідає змінна GOMAXPROCS? Яке її значення за замовчуванням?**

**29. Хто відповідає за планування горутин? Розкажіть про алгоритм роботи планувальника. Навіщо він потрібен, якщо вже й так є системні потоки?**

**30. Розкажіть про алгоритм роботи garbage collector. Mark and sweep, Reference counting та оптимізації алгоритму в мові Go. Що таке stop the world?**

**31. Які види багатозадачності ви знаєте? Який з них використовують у Go?**

**32. Для чого потрібна рефлексія? У чому різниця між рефлексією та кодогенерацією?**

**33. У чому різниця між value та reference типом? Назвіть декілька прикладів у мові Go.**

**34. Як зупинити горутину?**

**35. Як в Go реалізується спадкування?**

**36. Що таке lvalue і rvalue?**

**37. Яке у slice zero value?**

**38. Як вбудувати стандартний профайлер у свій застосунок?**

**39. Що таке map-reduce? Як його реалізувати в Go?**

**40. Як в Go працює префіксний інкремент/декремент?**

**41. Що буде, якщо перетворити в JSON-об’єкт, структура якого містить поля з малими літерами в назвах?**

**42. Як перервати for/switch або for/select?**

**43. Як можна оптимізувати виконання великої кількості послідовних операцій читання або запису?**

**44. Чи можна викликати метод у вказівника (pointer) на структуру, якщо він дорівнює nil?**

**45. Що буде при спробі запису в закритий канал?**

**46. Що таке взаємне блокування (deadlock)?**

**47. У чому особливість nil-каналів?**

**48. У яких випадках варто використовувати м’ютекси, а не канали, та навпаки?**

**49. Що таке білд-теги?**

**50. Як реалізувати LRU cache?**

**51. Що таке SSA-представлення?**

**52. Що ви знаєте про роботу з плагінами на Go?**

**53. Що таке аліаси типів?**

**54. Що таке падінги в структурах і на що вони впливають?**

**55. Що таке escape-аналіз?**

**56. Яка різниця між стеком і купою?**

**57. Що нам дає пакет unsafe?**

**58. Чи можна змінити певний символ у рядку? А за допомогою пакета unsafe?**

**59. Як працювати з рефлексією і що ми можемо з нею зробити?**

**60. Як під капотом виглядають слайси й мапи?**

**61. Як працювати з ``copy()``?**

**62. Як працювати з sync.Pool і [sync.Map](https://l.facebook.com/l.php?u=http%3A%2F%2Fsync.Map%2F%3Ffbclid%3DIwAR0IRDk_3BRFwVxRcE0uuDiDriYFAB-vmhE1kPgf-v4pAu-WVSAqs3RquBg&h=AT2u89KulT3y4yWcAEDgMTLEKrYnDjKrjAxEX6ycQ9dAB2T-Bzbvcph3lXrW-c1-uwxT24bKzuE1Y_rBdl3iNBYs8njT3uo8X3QJ4nqGhY7md3GKjNHy0lxtdvjTdtZtB2FIwy_scz0)? Які підводні камені вони мають?**

**63. Розкажіть про канкаренсі-патерни в Go.**

**64. Як у Go реалізована арифметика вказівників?***

### Практичні завдання

**65. Побудувати архітектуру бекенду для оренди самокатів типу Kiwi чи Bolt. Які мікросервіси будуть? Які мови та інструменти? Який клауд-провайдер? Що варто використати як інфраструктуру? Які бази даних та шини повідомлень?**

**66. Уявімо, що ви провідний розробник на проєкті, як би ви розподілили ролі в команді із 5 людей для найефективнішої роботи?**

**67. Є [код](https://play.golang.org/p/QSajZuzP-GN). Чому ``err! = nil``?**

**68. Вам дають ssh на сервер і просять полагодити вебзастосунок, який «впав». Інформації про сервер і сервіси немає. Які команди ви будете використовувати, щоб зібрати інформацію, знайти та усунути проблему?**

**69. Реалізуйте двійкову структуру даних дерева пошуку в Go.**

**70. Знайдіть максимальну суму шляху в трикутнику. (Подано числа у формі трикутника, починаючи з верхньої частини трикутника і рухаючись до сусідніх чисел у рядку внизу, знаходимо максимальну загальну кількість зверху вниз.)**
