# [Співбесіда з Go. 200+ запитань для Junior, Middle, Senior](https://dou.ua/lenta/articles/interview-questions-go-developer/)

## Junior

### Software engineering

**1. Які бувають області пам’яті програми? У чому їхні особливості та відмінності?**

Стек (Stack) це область пам'яті, де зберігаються локальні змінні та адреси повернення функцій. Стек працює за принципом (Last-In-First-Out, LIFO).

Куча (Heap) це область пам'яті, в якій зберігаються об'єкти, створені в програмі. Куча має динамічний розмір та керується операторами виділення та звільнення пам'яті.

Глобальна область (Global Area) це область пам'яті, в якій зберігаються глобальні змінні та функції.

Статична область (Static Area) це область пам'яті, в якій зберігаються статичні змінні та функції.

Константна область (Constant Area) це захищена від змін область пам'яті, в якій зберігаються константи, такі як рядки та числа.

**2. Розкажіть, що ви знаєте про HTTP-протокол, які складові частини запиту? Які статус-коди знаєте, які групи можна виділити?**

HTTP — це протокол передачі даних прикладного рівня, який використовується для передачі веб-сторінок, зображень, відео та інших даних між веб-клієнтом та веб-сервером.

HTTP-запит складається з трьох основних частин:

1. стартовий рядок ("Метод URI HTTP/Версія" для запиту та "HTTP/Версія Статус-код Опис" для відповіді);  
2. заголовки;  
3. тіло повідомлення, що містить дані запиту, запитаний ресурс або опис проблеми, якщо запит не виконано.

Коди статусу:

- 1хх — інформаційний: запит прийнятий, продовжуй процес.
- 2хх — успіх: дія була успішно передана, зрозуміла, та прийнята.
- 3хх — перенаправлення: наступні дії мають бути успішно виконані для реалізації запиту.
- 4хх — помилка клієнта: запит містить синтаксичні помилки або не може бути виконаний.
- 5хх — помилка сервера: сервер не зміг виконати правильно сформований запит.

Найбільш поширені статуси:

- 200 OK — запит виконано успішно.
- 301 Moved Permanently — ресурс переміщено.
- 403 Forbidden — доступ до запитаного ресурсу заборонений.
- 404 Not Found — ресурс не знайдений.
- 503 Service Unavailable — сервіс недоступний.

Методи:

OPTIONS — Повертає методи HTTP, які підтримуються сервером. Цей метод може служити для визначення можливостей вебсервера.

GET — Запитує вміст вказаного ресурсу. Запитаний ресурс може приймати параметри, які передаються в рядку URI. Згідно зі стандартом HTTP, запити типу GET вважаються ідемпотентними — багаторазове повторення одного і того ж запиту GET повинне приводити до однакових результатів (за умови, що сам ресурс не змінився за час між запитами). Це дозволяє кешувати відповіді на запити GET. Якщо назва ресурсу не вказана (у URI наявні лише схема та доменне ім'я), то вебсервер повертає індекс директорії вебсервера.

HEAD — Аналогічний методу GET, за винятком того, що у відповіді сервера відсутнє тіло. Це корисно для витягання метаінформації, заданої в заголовках відповіді, без пересилання всього вмісту. Зокрема, клієнт чи проксі, перевіривши заголовок Last-Modified: (останній час модифікації), таким чином може переконатися, що сторінка на сервері не змінилася від часу попереднього запиту.

POST — Передає призначені для користувача дані (наприклад, з HTML-форми) заданому ресурсу. Наприклад, в блогах відвідувачі зазвичай можуть вводити свої коментарі до записів в HTML-форму, після чого вони передаються серверу методом POST, і він поміщає їх на сторінку. При цьому передані дані (у прикладі з блогами — текст коментаря) включаються в Тіло запиту (Request body). На відміну від методу GET, метод POST не вважається ідемпотентним, тобто багаторазове повторення одних і тих же запитів POST може повертати різні результати (наприклад, після кожного відправлення коментаря з'являтиметься одна копія цього коментаря).

PUT — Завантажує вказаний ресурс на сервер.

PATCH — Завантажує певну частину ресурсу на сервер.

DELETE — Видаляє вказаний ресурс.

TRACE — Повертає отриманий запит так, що клієнт може побачити, що проміжні сервери додають або змінюють в запиті.

CONNECT — Для використання разом з проксі-серверами, які можуть динамічно перемикатися в тунельний режим SSL.

**3. Назвіть та опишіть будь-який патерн програмування (на ваш вибір). Коли його доцільно використовувати та чому?**

**4. Що таке процеси та потоки в операційній системі? Опишіть їхній взаємозв’язок у контексті виконання програми.**

Процес — завантажена в пам'ять і готова до виконання програма, яка складається з коду, даних і інших системних ресурсів, таких як відкриті файли та канали.

Потік (thread) — базовий об'єкт, якому операційна система розподіляє час центрального процесора.

Виконання процесу починається зі стартового потоку. Надалі він може породжувати інші потоки. Ресурси процесу доступні всім його потокам. Кожен потік використовує структуру даних, для збереження контексту виконання, у той час, коли в нього віднімається процесор. У контекст входять регістри процесора, перемінні оточення, стеки ядра і користувача. Усі потоки одного процесу спільно використовують його віртуальний адресний простір.

Процесорний час розподіляється по черзі між потоками, а не між процесами.

**5. Що таке шаблон проєктування (design pattern)?**

[Шаблони проєктування](https://uk.wikipedia.org/wiki/Шаблони_проєктування_програмного_забезпечення) — ефективні способи вирішення задач проєктування програмного забезпечення. Об'єктно-орієнтований шаблон найчастіше є зразком вирішення проблеми і відображає відношення між класами та об'єктами, без вказівки на те, як буде зрештою реалізоване це відношення.

Типи шаблонів «Банди чотирьох» (Gang of Four, GOF — Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides), опубліковані в 1991 р. в книзі «Design Patterns — Elements of Reusable Object-Oriented Software»:

- Основні шаблони
- [Твірні шаблони](https://uk.wikipedia.org/wiki/%D0%A2%D0%B2%D1%96%D1%80%D0%BD%D1%96_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8) (Abstract Factory, Builder, Dependency Injection, Singleton, Prototype, Factory Method, Resource Acquisition Is Initialization, Lazy initialization, Object pool, Multiton pattern)
- [Структурні шаблони](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%96_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8) (Adapter, Decorator, Proxy, Composite, Bridge, Flyweight, Facade, Module)
- [Шаблони поведінки](https://uk.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D1%96%D0%BD%D0%BA%D0%B8) (Visitor, Interpreter, Iterator, Command, Chain of Responsibility, Mediator, Front controller, Observer, State, Strategy, Memento, Template Method)
- [Шаблони паралельних операцій (конкурентного програмування)](https://uk.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82%D0%B5%D1%80%D0%BD%D0%B8_%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) (Active Object, Balking pattern, Barrier, Double-checked locking, Guarded suspension, Leaders/followers pattern, Monitor Object, Reactor pattern, Readers write lock pattern, Scheduler pattern, Thread pool pattern, Thread-local storage)

Також існує інша група шаблонів проєктування, що отримала назву [GRASP](https://uk.wikipedia.org/wiki/GRASP) — General Responsibility Assignment Software Patterns. Опис цих шаблонів наводить Craig Larman у своїй книзі «Applying UML and Patterns»:

- Інформаційний експерт (Information Expert)
- Творець примірників класу (Creator)
- Низька зв'язаність (Low Coupling)
- Високе зчеплення (High Cohesion)
- Контролер (Controller)
- Поліморфізм (Polymorphism)
- Штучний (Pure Fabrication)
- Перенаправлення (Indirection)
- Стійкий до змін (Protected Variations)

Шаблони GRASP формулюють найбільш базові принципи розподілу обов'язків між типами.

**6. Які знаєте алгоритми сортування?**

Відомі алгоритми сортування:

За час O(n^2):

- [Сортування вибором](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B2%D0%B8%D0%B1%D0%BE%D1%80%D0%BE%D0%BC) — (Selection sort) — пошук найменшого або найбільшого елемента і переміщення його в початок або кінець впорядкованого списку.
- [Сортування вставкою](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%BE%D1%8E) (включенням, Insertion sort) — визначаємо місце, де поточний елемент повинен знаходитися в упорядкованому списку, і вставляємо його туди.
- [Сортування обміном](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BE%D0%B1%D0%BC%D1%96%D0%BD%D0%BE%D0%BC) (сортування бульбашкою, Bubble sort) — для кожної пари індексів проводиться обмін, якщо елементи розташовані не по порядку.
- Сортування методом бінарної вставки

За час O(n log n):

- [Плавне сортування](https://uk.wikipedia.org/wiki/%D0%9F%D0%BB%D0%B0%D0%B2%D0%BD%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) (Smoothsort)
- [Пірамідальне сортування](https://uk.wikipedia.org/wiki/%D0%9F%D1%96%D1%80%D0%B0%D0%BC%D1%96%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
- [Швидке сортування](https://uk.wikipedia.org/wiki/%D0%A8%D0%B2%D0%B8%D0%B4%D0%BA%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
- [Сортування злиттям](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%BB%D0%B8%D1%82%D1%82%D1%8F%D0%BC)
- [Timsort](https://uk.wikipedia.org/wiki/Timsort)

За час O(n):

- [Сортування підрахунком](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BF%D1%96%D0%B4%D1%80%D0%B0%D1%85%D1%83%D0%BD%D0%BA%D0%BE%D0%BC)
- [Сортування за розрядами](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0_%D1%80%D0%BE%D0%B7%D1%80%D1%8F%D0%B4%D0%B0%D0%BC%D0%B8)
- [Сортування комірками](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BA%D0%BE%D0%BC%D1%96%D1%80%D0%BA%D0%B0%D0%BC%D0%B8)

За час O(n log^2 n):

- [Сортування злиттям модифіковане](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%BB%D0%B8%D1%82%D1%82%D1%8F%D0%BC_%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D1%96%D0%BA%D0%BE%D0%B2%D0%B0%D0%BD%D0%B5)
- [Сортування Шелла](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%A8%D0%B5%D0%BB%D0%BB%D0%B0)

За час O(n n!):

- Сортування перестановкою
- [Випадкове сортування](https://uk.wikipedia.org/wiki/%D0%92%D0%B8%D0%BF%D0%B0%D0%B4%D0%BA%D0%BE%D0%B2%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)

**7. Що таке Big-O notation?**

Big-O (Нотація Ландау) — поширена математична нотація для формального запису асимптотичної поведінки функцій. Це міра того, як швидко буде сповільнюватись робота коду з ростом кількості вхідних даних.

**8. Які відмінності між unit-тестом та інтеграційним тестом?**

Модульний тест — це метод тестування, за допомогою якого тестуються окремі одиниці вихідного коду, щоб визначити, чи готові вони до використання. Це допомагає зменшити вартість виправлення помилок, оскільки помилки виявляються на ранніх фазах життєвого циклу розробки.

Це свого роду тестування White Box; його можна виконати в будь-який час; не перевіряє, чи правильно код працює із зовнішніми залежностями; зазвичай його виконує розробник; знайти помилки легко; обслуговування є дешевим.

Інтеграційний тест — це техніка тестування програмного забезпечення, коли окремі блоки програми об'єднуються та перевіряються як група. Тестові заглушки та тестові драйвери використовуються для сприяння інтеграційному тестуванню.

Це свого роду тестування «чорної скриньки»; зазвичай проводиться після модульного тестування та перед тестуванням системи; звертає увагу на інтеграцію між модулями; перевіряє, чи правильно код працює із зовнішніми залежностями; зазвичай його виконує тестова група; знайти помилки складно; обслуговування є дорогим.

**9. Що таке mock і для чого його використовують?**

Макети об'єктів (Mock Object) у об'єктно-орієнтованому програмуванні — це об'єкти, що імітують поведінку справжніх об'єктів контрольованими способами, тобто, реалізують інтерфейси справжніх об'єктів, але не мають власної реальної функціональності. Програміст зазвичай створює макет об'єкта для тестування поведінки інших об'єктів.

Корисні, коли реальний об'єкт недоцільно або неможливо використати в модульному тесті, наприклад коли об'єкт:

- надає недетерміновані результати (наприклад, час або температуру);
- є сценарії, які важко створити або відтворити (наприклад, помилка в мережі);
- повільно працює (наприклад, повна база даних, яка повинна бути ініціалізована до початку тестування);
- ще не існує або може змінити поведінку;
- повинен включати в себе інформацію і методи виключно для цілей тестування (а не для реального використання).

**10. Що таке SDLC? Які етапи й навіщо вони потрібні?**

Життєвий цикл розробки програмного забезпечення (Software development lifecycle) — це повний процес розробки програмного рішення від ідеї до створення, розгортання та обслуговування.

Це детальний і визначений план етапів, який розробники використовують для планування, створення, тестування, розгортання та підтримки програмного рішення і який допомагає створювати якісне програмне забезпечення, що відповідає вимогам клієнтів і завершується в рамках оцінки витрат і встановлених часових рамок.

Зазвичай він включає сім етапів:

1. Аналіз вимог (Requirement Analysis) — документуються функціональні та нефункціональні вимоги, створюється специфікація програмного забезпечення.
2. Планування (Planning) — вирішуються питання, як буде виконуватися розробка, хто буде виконувати завдання, які витрати.
3. Дизайн системи (Architectural Design) — визначаються елементи системи, рівень безпеки, процес обробки та збереження інформації, технології, які будуть використовуватися.
4. Розробка (Software Development) — на цьому етапі починає писатися код.
5. Тестування (Testing) — тестування та виправлення знайдених дефектів.
6. Розгортання (Deployment) — надання програмного забезпечення кінцевим користувачам.
7. Експлуатація та обслуговування (Maintenance) — технічна підтримка продукту, зворотній зв’язок з користувачами.

**11. Що таке SOLID?**

SOLID — це абревіатура, складена з перших літер п'яти базових принципів об'єктно-орієнтованого програмування та дизайну і запропонована Робертом Мартіном у статті 2000 року Design Principles and Design Patterns:

- **S**RP, Single responsibility principle ([Принцип єдиного обов'язку](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%94%D0%B4%D0%B8%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%BE%D0%B2%27%D1%8F%D0%B7%D0%BA%D1%83)): кожен об'єкт має виконувати лише один обов'язок.
- **O**CP, Open/closed principle ([Принцип відкритості/закритості](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B2%D1%96%D0%B4%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96/%D0%B7%D0%B0%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96)): програмні сутності повинні бути відкритими для розширення, але закритими для змін. Тобто, має бути спосіб змінювати поведінку програмних модулів без потреби змінювати їхній вихідний код (наприклад, через механізм динамічного або статичного поліморфізму).
- **L**SP, Liskov substitution principle ([Принцип підстановки Лісков](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D1%96%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%9B%D1%96%D1%81%D0%BA%D0%BE%D0%B2)): об'єкти в програмі можуть бути заміненими їхніми нащадками без зміни коду програми.
- **I**SP, Interface segregation principle ([Принцип розділення інтерфейсу](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%80%D0%BE%D0%B7%D0%B4%D1%96%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F_%D1%96%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%83)): багато спеціалізованих інтерфейсів краще за один універсальний. Інтерфейс може бути поділений на спеціалізовані ще на стадії проєктування, заради майбутньої гнучкості програмних компонентів.
- **D**IP, Dependency inversion principle ([Принцип інверсії залежностей](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%96%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D1%96%D1%97_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)): залежності всередині системи будуються на основі абстракцій, що не повинні залежати від деталей; навпаки, деталі мають залежати від абстракцій. Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.

Принципи SOLID використовують для дизайну та розробки таких програмних систем, які, з великою ймовірністю, зможуть тривалий час розвиватися, розширятися і підтримуватися.

**12. Що таке MVC?**

Модель–вигляд/представлення–контролер (MVC, Model-view-controller) — архітектурний шаблон, який використовується під час проєктування та розробки програмного забезпечення.

Цей шаблон передбачає поділ системи на три взаємопов'язані частини: модель даних, вигляд (інтерфейс користувача) та модуль керування.

![MVC](https://upload.wikimedia.org/wikipedia/uk/thumb/d/d0/%D0%94%D1%96%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%B2%D0%B7%D0%B0%D1%94%D0%BC%D0%BE%D0%B4%D1%96%D1%97_%D0%BC%D1%96%D0%B6_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%83_MVC.png/400px-%D0%94%D1%96%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%B2%D0%B7%D0%B0%D1%94%D0%BC%D0%BE%D0%B4%D1%96%D1%97_%D0%BC%D1%96%D0%B6_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%83_MVC.png "MVC")

Застосовується для відокремлення даних (моделі) від інтерфейсу користувача (вигляду) так, щоб зміни інтерфейсу користувача мінімально впливали на роботу з даними, а зміни в моделі даних могли здійснюватися без змін інтерфейсу користувача, що створює гнучкий дизайн програмного забезпечення, який повинен полегшувати подальші зміни чи розширення програм, а також надавати можливість повторного використання окремих компонентів програми.

Крім того використання цього шаблону у великих системах сприяє впорядкованості їхньої структури і робить їх більш зрозумілими за рахунок зменшення складності.

**13. Що таке DBMS? Яка різниця між СУБД та базою даних?**

**14. Які бувають типи баз даних?**

**15. Що таке Docker?**


### Бази даних

**16. Опишіть ACID-властивості реляційних баз даних.**

**17. Є таблиця в реляційній БД зі 100 тисячами рядків. SELECT-запит з такої таблиці триває час *t*. Як зміниться час запиту, якщо кількість рядків буде один мільйон? Які є варіанти, залежно від запиту/таблиці?**

**18. Для чого використовують індекси в базах даних і завдяки чому (яким структурам даних) вони працюють?**

**19. З якими NoSQL-базами даних працювали? Які їхні переваги над реляційними базами?**

### Go

**20. На вашу думку, у чому перевага Go перед іншими мовами?**

**21. Що таке горутини й навіщо вони?**

**22. Що таке GOROOT і GOPATH?**

**23. Які типи даних використовуються в Go?**

**24. Що робить функція ``init()``? Наведіть приклади, де її варто використовувати. Наведіть приклади, коли варто уникати.**

**25. Поясніть різницю між помилкою і панікою.**

**26. Як відловлювати паніки?**

**27. Як отримати теперішній час?**

**28. Що таке iota?**

**29. Яка різниця між слайсом і масивом?**

**30. З яких частин складається змінна типу slice?**

**31. Як працює append?**

**32. Що таке len і capacity в slice?**

**33. Що таке пакети?**

**34. Що таке інтерфейси і як вони працюють?**

**35. Для чого потрібні інтерфейси в Golang?**

**36. Що таке тип даних string?**

**37. Чим відрізняються лапки в Go (подвійні, одинарні, зворотні): ``""``,``''``, ``\`\```?**

**38. Що таке rune?**

**39. Чи може змінна типу string приймати nil-значення?**

**40. Чи можна повернути з функції кілька значень?**

**41. Що відбувається під час конкатенації рядків?**

**42. Як ефективно склеїти кілька рядків?**

**43. Як записати в файл?**

**44. Що таке структура?**

**45. Що буде, якщо викликати ``log.Fatal``?**

**46. Поясніть різницю між конкурентністю і паралельністю?**

**47. Як оголосити відкладений виклик?**

**48. Що таке канал? Які типи каналів ви знаєте? Для чого вони потрібні?**

**49. Яка різниця між буферизованим і небуферизованим каналами?**

**50. Що буде, якщо читати із закритого каналу? Що буде, якщо писати у закритий канал?**

**51. Як перевірити, що змінна типу map має збережене значення для певного ключа?**

**52. Які стандартні env-змінні в Go?**

**53. Яка різниця між value & pointer receiver?**

**54. Як зробити type assertion?**

**55. Як та навіщо робити type assertion?**

**56. Як написати benchmark?**

**57. В якому порядку виконуються кейси в select?**

### Практичні завдання

**58. Реалізувати алгоритм двійкового пошуку елемента у слайсі.**

**59. Є [код](https://play.golang.org/p/a-JIesxdCQ7). Що виведеться на екран? Що потрібно зробити, щоб побачити запропонований висновок Foo1 і Foo2?**

**60. Є [код](https://play.golang.org/p/6CiZvQp7r3t). Що виведеться на екран? Як вивести на екран літери?**

**61. Поміняйте місцями значення двох змінних без тимчасової допоміжної змінної.**

**62. Оберніть slice у зворотному порядку.**

**63. Перемістіть усі zero values у кінець масиву.**

## Middle

### Software engineering

**1. У чому переваги та недоліки використання protobuf у порівнянні з JSON?**

**2. Назвіть деякі з принципів 12-factor-app. Для чого використовують graceful shutdown?**

**3. Що таке dependency injection? А dependency inversion?**

**4. У вас є ssh-доступ на Linux-сервер, де запущено вебсервер. З сервером періодично відбуваються незаплановані рестарти. Сервер записує логи у файли (розмір лог-файлу &gt; 10 Mb). Які *nix-команди ви можете використати, щоб проаналізувати проблему?**

**5. Як працює TLS handshake?**

**6. Яка різниця між TCP & UDP? В якій ситуації UPD краще?**

**7. Розкажіть у найдрібніших деталях, що відбувається, коли клієнт посилає запит на сервер, а сервер цей запит отримує.**

**8. Що таке Clean Architecture? Наведіть приклад.**

**9. Що таке оперативна пам’ять?**

**10. Як різниця між stack & heap?**

**11. Для чого потрібні Docker та Kubernetes?**

**12. Розкажіть про абстракції Kubernetes, з якими працювали?**

**13. Що таке Pod? Як він влаштований?**

**14. Розкажіть про Data structures: stack, queue, linked list, trie, balanced tree.**

### Бази даних

**15. Які шляхи пошуку повільних SELECT-запитів у RDBMS? Які способи пришвидшення таких запитів?**

**16. Що таке нормальні форми бази даних?**

**17. Що таке індекси? Які їхні недоліки?**

**18. Які структури даних можуть використовуватися в індексах баз даних? Як вони працюють?**

**19. Яка різниця між foreign & primary key?**

**20. Поняття міграції у контексті баз даних. У чому переваги підходу з міграціями?**

**21. Що таке реплікація даних? Які варіанти реплікації існують для баз, з якими ви працювали?**

**22. Яка різниця між SQL і NoSQL?**

**23. Які типи NoSQL баз даних ви знаєте? Наведіть приклади. Яка між ними різниця?**

**24. Що таке колонкова БД? Переваги та недоліки.**

**25. Що таке документоорієнтована БД? Переваги та недоліки.**

**26. Розкажіть про роботу з key-value базами даних (бажано з власного досвіду).**

**27. З якими типами даних Redis у вас є практичний досвід? Назвіть приклади, коли їх доцільно використовувати.**

### Go

**28. Якими бібліотеками Go ви користувалися для доступу до RDBMS? Які у них позитивні та негативні сторони?**

**29. Для чого використовують Context? Які є варіанти скасовування контекстів?**

**30. Якими способами можна виключити (приховати) поля структури при JSON-серіалізації?**

**31. Назвіть примітиви пакету sync стандартної бібліотеки. Яке призначення та приклади застосування ``sync.WaitGroup``?**

**32. Яка різниця між Mutex та RWMutex?**

**33. Які є способи зупинити N горутин, запущених одночасно (наприклад, worker pool)?**

**34. Що таке замикання функцій?**

**35. Поясніть різницю між switch і select?**

**36. Які є способи дістати дані з JSON?**

**37. Як у Go реалізовані конструкції циклів?**

**38. Як влаштований тип map?**

**39. Який порядок перебору map?**

**40. Що таке серіалізація? Де вона застосовується?**

**41. Чи можна використовувати nil для ініціалізації змінної?**

**42. Чи можна задати місткість map? Чи можна отримати місткість map?**

**43. Як дізнатися кількість символів у рядку?**

**44. Що таке кодогенерація і для чого вона потрібна?**

**45. Чим відрізняється goroutine від OS thread?**

**46. Як і для чого використовують ``io.Reader`` і ``io.Writer``?**

**47. Як перетворити ``[]io.ReadWriter`` на ``[]io.Reader``?**

**48. Як вказати головній горутині очікувати завершення роботи всіх робочих горутин?**

**49. Чи завжди буде швидше передача Pointer як аргументу функції?**

**50. Що таке варіативна змінна функції? Як працювати з цією змінною?**

**51. Як працювати з пакетом internal?**

**52. Як працює імпорт через крапочку і чому це погана практика?**

**53. Як працює імпорт через підкреслення?**

**54. Що таке ``defer()``?**

**55. Як працювати з goto?**

**56. Що таке ``reflect.DeepEqual()`` і ``reflect.TypeOf()``?**

**57. Як розпарсити час?**

**58. Як порівняти дві дати?**

**59. Що таке вказівник і як з ним працювати?**

**60. Як перевірити, чи змінна імплементує інтерфейс?**

**61. Що таке embedding?**

**62. Опишіть кроки процесу тестування.**

**63. Як писати тести? Що таке табличні тести?**

**64. Що таке memory leak? Які є способи його виявлення? Як його позбутися?**

**65. Що таке race condition? Які є способи його виявлення? Як його позбутися?**

### Практичні завдання

**67. Реалізувати перевірку на слова на анаграму. Написати тест і бенчмарк. Оцінити складність розробленого алгоритму.**

**68. Є [код](https://play.golang.org/p/-3o2gp3enIG). Що виведеться на екран? Чому?**

**69. Є [код](https://play.golang.org/p/qwC_nJNFdEy). Чи можна передбачити, що виведеться на екран? Чому?**

**70. Реалізуйте Stack (LIFO).**

**71. Реалізуйте linked list.**

**72. Задача про суму підмножини (Subset Sum Problem). Дано: множина позитивних цілих чисел і значення sum. Визначте, чи існує підмножина даної множини з сумою, яка дорівнює значенню sum.  **
``Input: set [] = { 3 , 34 , 4 , 12 , 5 , 2 }, sum = 9``  
``Output: True``

## Senior

### Software engineering

**1. Що таке процес і потік? Як вони пов’язані між собою? Чи мають різні процеси чи потоки доступу до однієї області пам’яті?**

**2. Які інструменти зазвичай використовують для збору метрик і логів? Як працює Prometheus?**

**3. Як працює docker під капотом?**

**4. Як працює load balancer під капотом?**

**5. Для чого потрібні черги?**

**6. Що таке CQRS?**

**7. Які архітектури програмного забезпечення ви знаєте?**

**8. Яка різниця між мікросервісами та монолітом? Які є переваги та недоліки?**

**9. Як побудувати міжсервісну транзакцію?**

**10. Що таке розподілені транзакції? Як реалізувати?**

**11. Які проблеми вирішує патерн Saga?**

**12. Як реалізувати аутентифікацію в мікросервісній архітектурі?**

**13. Що таке Event Sourcing?**

**14. Сформулюйте CAP-теорему.**

**15. Розкажіть про Raft Consensus Algorithm.**

**16. У чому різниця між імперативною і декларативною парадигмою програмування? Наведіть приклади мов.**

### Бази даних

**17. Для чого потрібні графові бази даних?**

**18. Якщо точкові дані прив’язані до часу, які бази даних варто використовувати для збереження цих даних?**

**19. Що таке Materialized View? У чому відмінність від звичайного View?**

**20. Що таке ACID? Прокоментуйте, як ACID реалізований в PostgreSQL.**

**21. Яка різниця між BASE та ACID?**

**22. Назвіть рівні ізоляції транзакцій?**

**23. Досвід оптимізації бази. Які інструменти використовували?**

**24. Що таке шардинг? Які види є?**

**25. Як працює master-slave реплікація?**

**26. Як працюють індекси? Як вибрати індекси в таблицях?**

**27. Розкажіть про optimistic та pessimistic locking.**

### Go

**28. За що відповідає змінна GOMAXPROCS? Яке її значення за замовчуванням?**

**29. Хто відповідає за планування горутин? Розкажіть про алгоритм роботи планувальника. Навіщо він потрібен, якщо вже й так є системні потоки?**

**30. Розкажіть про алгоритм роботи garbage collector. Mark and sweep, Reference counting та оптимізації алгоритму в мові Go. Що таке stop the world?**

**31. Які види багатозадачності ви знаєте? Який з них використовують у Go?**

**32. Для чого потрібна рефлексія? У чому різниця між рефлексією та кодогенерацією?**

**33. У чому різниця між value та reference типом? Назвіть декілька прикладів у мові Go.**

**34. Як зупинити горутину?**

**35. Як в Go реалізується спадкування?**

**36. Що таке lvalue і rvalue?**

**37. Яке у slice zero value?**

**38. Як вбудувати стандартний профайлер у свій застосунок?**

**39. Що таке map-reduce? Як його реалізувати в Go?**

**40. Як в Go працює префіксний інкремент/декремент?**

**41. Що буде, якщо перетворити в JSON-об’єкт, структура якого містить поля з малими літерами в назвах?**

**42. Як перервати for/switch або for/select?**

**43. Як можна оптимізувати виконання великої кількості послідовних операцій читання або запису?**

**44. Чи можна викликати метод у вказівника (pointer) на структуру, якщо він дорівнює nil?**

**45. Що буде при спробі запису в закритий канал?**

**46. Що таке взаємне блокування (deadlock)?**

**47. У чому особливість nil-каналів?**

**48. У яких випадках варто використовувати м’ютекси, а не канали, та навпаки?**

**49. Що таке білд-теги?**

**50. Як реалізувати LRU cache?**

**51. Що таке SSA-представлення?**

**52. Що ви знаєте про роботу з плагінами на Go?**

**53. Що таке аліаси типів?**

**54. Що таке падінги в структурах і на що вони впливають?**

**55. Що таке escape-аналіз?**

**56. Яка різниця між стеком і купою?**

**57. Що нам дає пакет unsafe?**

**58. Чи можна змінити певний символ у рядку? А за допомогою пакета unsafe?**

**59. Як працювати з рефлексією і що ми можемо з нею зробити?**

**60. Як під капотом виглядають слайси й мапи?**

**61. Як працювати з ``copy()``?**

**62. Як працювати з sync.Pool і [sync.Map](https://l.facebook.com/l.php?u=http%3A%2F%2Fsync.Map%2F%3Ffbclid%3DIwAR0IRDk_3BRFwVxRcE0uuDiDriYFAB-vmhE1kPgf-v4pAu-WVSAqs3RquBg&h=AT2u89KulT3y4yWcAEDgMTLEKrYnDjKrjAxEX6ycQ9dAB2T-Bzbvcph3lXrW-c1-uwxT24bKzuE1Y_rBdl3iNBYs8njT3uo8X3QJ4nqGhY7md3GKjNHy0lxtdvjTdtZtB2FIwy_scz0)? Які підводні камені вони мають?**

**63. Розкажіть про канкаренсі-патерни в Go.**

**64. Як у Go реалізована арифметика вказівників?***

### Практичні завдання

**65. Побудувати архітектуру бекенду для оренди самокатів типу Kiwi чи Bolt. Які мікросервіси будуть? Які мови та інструменти? Який клауд-провайдер? Що варто використати як інфраструктуру? Які бази даних та шини повідомлень?**

**66. Уявімо, що ви провідний розробник на проєкті, як би ви розподілили ролі в команді із 5 людей для найефективнішої роботи?**

**67. Є [код](https://play.golang.org/p/QSajZuzP-GN). Чому ``err! = nil``?**

**68. Вам дають ssh на сервер і просять полагодити вебзастосунок, який «впав». Інформації про сервер і сервіси немає. Які команди ви будете використовувати, щоб зібрати інформацію, знайти та усунути проблему?**

**69. Реалізуйте двійкову структуру даних дерева пошуку в Go.**

**70. Знайдіть максимальну суму шляху в трикутнику. (Подано числа у формі трикутника, починаючи з верхньої частини трикутника і рухаючись до сусідніх чисел у рядку внизу, знаходимо максимальну загальну кількість зверху вниз.)**
