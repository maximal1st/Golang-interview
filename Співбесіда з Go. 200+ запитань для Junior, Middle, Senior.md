# [Співбесіда з Go. 200+ запитань для Junior, Middle, Senior](https://dou.ua/lenta/articles/interview-questions-go-developer/)

## Junior

### Software engineering

**1. Які бувають області пам’яті програми? У чому їхні особливості та відмінності?**

Стек (Stack) це область пам'яті, де зберігаються локальні змінні та адреси повернення функцій. Стек працює за принципом (Last-In-First-Out, LIFO).

Куча (Heap) це область пам'яті, в якій зберігаються об'єкти, створені в програмі. Куча має динамічний розмір та керується операторами виділення та звільнення пам'яті.

Глобальна область (Global Area) це область пам'яті, в якій зберігаються глобальні змінні та функції.

Статична область (Static Area) це область пам'яті, в якій зберігаються статичні змінні та функції.

Константна область (Constant Area) це захищена від змін область пам'яті, в якій зберігаються константи, такі як рядки та числа.

**2. Розкажіть, що ви знаєте про HTTP-протокол, які складові частини запиту? Які статус-коди знаєте, які групи можна виділити?**

HTTP — це протокол передачі даних прикладного рівня, який використовується для передачі веб-сторінок, зображень, відео та інших даних між веб-клієнтом та веб-сервером.

HTTP-запит складається з трьох основних частин:

1. стартовий рядок ("Метод URI HTTP/Версія" для запиту та "HTTP/Версія Статус-код Опис" для відповіді);
2. заголовки;
3. тіло повідомлення, що містить дані запиту, запитаний ресурс або опис проблеми, якщо запит не виконано.

Коди статусу:

- 1хх — інформаційний: запит прийнятий, продовжуй процес.
- 2хх — успіх: дія була успішно передана, зрозуміла, та прийнята.
- 3хх — перенаправлення: наступні дії мають бути успішно виконані для реалізації запиту.
- 4хх — помилка клієнта: запит містить синтаксичні помилки або не може бути виконаний.
- 5хх — помилка сервера: сервер не зміг виконати правильно сформований запит.

Найбільш поширені статуси:

- 200 OK — запит виконано успішно.
- 301 Moved Permanently — ресурс переміщено.
- 403 Forbidden — доступ до запитаного ресурсу заборонений.
- 404 Not Found — ресурс не знайдений.
- 503 Service Unavailable — сервіс недоступний.

Методи:

OPTIONS — Повертає методи HTTP, які підтримуються сервером. Цей метод може служити для визначення можливостей вебсервера.

GET — Запитує вміст вказаного ресурсу. Запитаний ресурс може приймати параметри, які передаються в рядку URI. Згідно зі стандартом HTTP, запити типу GET вважаються ідемпотентними — багаторазове повторення одного і того ж запиту GET повинне приводити до однакових результатів (за умови, що сам ресурс не змінився за час між запитами). Це дозволяє кешувати відповіді на запити GET. Якщо назва ресурсу не вказана (у URI наявні лише схема та доменне ім'я), то вебсервер повертає індекс директорії вебсервера.

HEAD — Аналогічний методу GET, за винятком того, що у відповіді сервера відсутнє тіло. Це корисно для витягання метаінформації, заданої в заголовках відповіді, без пересилання всього вмісту. Зокрема, клієнт чи проксі, перевіривши заголовок Last-Modified: (останній час модифікації), таким чином може переконатися, що сторінка на сервері не змінилася від часу попереднього запиту.

POST — Передає призначені для користувача дані (наприклад, з HTML-форми) заданому ресурсу. Наприклад, в блогах відвідувачі зазвичай можуть вводити свої коментарі до записів в HTML-форму, після чого вони передаються серверу методом POST, і він поміщає їх на сторінку. При цьому передані дані (у прикладі з блогами — текст коментаря) включаються в Тіло запиту (Request body). На відміну від методу GET, метод POST не вважається ідемпотентним, тобто багаторазове повторення одних і тих же запитів POST може повертати різні результати (наприклад, після кожного відправлення коментаря з'являтиметься одна копія цього коментаря).

PUT — Завантажує вказаний ресурс на сервер.

PATCH — Завантажує певну частину ресурсу на сервер.

DELETE — Видаляє вказаний ресурс.

TRACE — Повертає отриманий запит так, що клієнт може побачити, що проміжні сервери додають або змінюють в запиті.

CONNECT — Для використання разом з проксі-серверами, які можуть динамічно перемикатися в тунельний режим SSL.

**3. Назвіть та опишіть будь-який патерн програмування (на ваш вибір). Коли його доцільно використовувати та чому?**

**4. Що таке процеси та потоки в операційній системі? Опишіть їхній взаємозв’язок у контексті виконання програми.**

Процес — завантажена в пам'ять і готова до виконання програма, яка складається з коду, даних і інших системних ресурсів, таких як відкриті файли та канали.

Потік (thread) — базовий об'єкт, якому операційна система розподіляє час центрального процесора.

Виконання процесу починається зі стартового потоку. Надалі він може породжувати інші потоки. Ресурси процесу доступні всім його потокам. Кожен потік використовує структуру даних, для збереження контексту виконання, у той час, коли в нього віднімається процесор. У контекст входять регістри процесора, перемінні оточення, стеки ядра і користувача. Усі потоки одного процесу спільно використовують його віртуальний адресний простір.

Процесорний час розподіляється по черзі між потоками, а не між процесами.

**5. Що таке шаблон проєктування (design pattern)?**

[Шаблони проєктування](https://uk.wikipedia.org/wiki/Шаблони_проєктування_програмного_забезпечення) — ефективні способи вирішення задач проєктування програмного забезпечення. Об'єктно-орієнтований шаблон найчастіше є зразком вирішення проблеми і відображає відношення між класами та об'єктами, без вказівки на те, як буде зрештою реалізоване це відношення.

Типи шаблонів «Банди чотирьох» (Gang of Four, GOF — Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides), опубліковані в 1991 р. в книзі «Design Patterns — Elements of Reusable Object-Oriented Software»:

- Основні шаблони
- [Твірні шаблони](https://uk.wikipedia.org/wiki/%D0%A2%D0%B2%D1%96%D1%80%D0%BD%D1%96_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8)
([Abstract Factory](https://uk.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Builder](https://uk.wikipedia.org/wiki/%D0%91%D1%83%D0%B4%D1%96%D0%B2%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Dependency Injection](https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9),
[Singleton](https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Prototype](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Factory Method](https://uk.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Resource Acquisition Is Initialization](https://uk.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization),
[Lazy initialization](https://uk.wikipedia.org/wiki/%D0%9B%D1%96%D0%BD%D0%B8%D0%B2%D0%B0_%D1%96%D0%BD%D1%96%D1%86%D1%96%D0%B0%D0%BB%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F),
[Object pool](https://uk.wikipedia.org/wiki/%D0%9F%D1%83%D0%BB_%D0%BE%D0%B1%27%D1%94%D0%BA%D1%82%D1%96%D0%B2_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Multiton pattern](https://uk.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D1%82%D0%BE%D0%BD_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)))
- [Структурні шаблони](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%96_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8)
([Adapter](https://uk.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Decorator](https://uk.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Proxy](https://uk.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%96%D1%81%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Composite](https://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D1%83%D0%B2%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Bridge](https://uk.wikipedia.org/wiki/%D0%9C%D1%96%D1%81%D1%82_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Flyweight](https://uk.wikipedia.org/wiki/%D0%9B%D0%B5%D0%B3%D0%BA%D0%BE%D0%B2%D0%B0%D0%B3%D0%BE%D0%B2%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Facade](https://uk.wikipedia.org/wiki/%D0%A4%D0%B0%D1%81%D0%B0%D0%B4_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Module](https://uk.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\))
- [Шаблони поведінки](https://uk.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D1%96%D0%BD%D0%BA%D0%B8)
([Visitor](https://uk.wikipedia.org/wiki/%D0%92%D1%96%D0%B4%D0%B2%D1%96%D0%B4%D1%83%D0%B2%D0%B0%D1%87_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Interpreter](https://uk.wikipedia.org/wiki/%D0%86%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Iterator](https://uk.wikipedia.org/wiki/%D0%86%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Command](https://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Chain of Responsibility](https://uk.wikipedia.org/wiki/%D0%9B%D0%B0%D0%BD%D1%86%D1%8E%D0%B6%D0%BE%D0%BA_%D0%B2%D1%96%D0%B4%D0%BF%D0%BE%D0%B2%D1%96%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9),
[Mediator](https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Front controller](https://uk.wikipedia.org/wiki/Front_controller),
[Observer](https://uk.wikipedia.org/wiki/%D0%A1%D0%BF%D0%BE%D1%81%D1%82%D0%B5%D1%80%D1%96%D0%B3%D0%B0%D1%87_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[State](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BD_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Strategy](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D1%96%D1%8F_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Memento](https://uk.wikipedia.org/wiki/%D0%97%D0%BD%D1%96%D0%BC%D0%BE%D0%BA_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)),
[Template Method](https://uk.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F\)))
- [Шаблони паралельних операцій (конкурентного програмування)](https://uk.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82%D0%B5%D1%80%D0%BD%D0%B8_%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
([Active Object](https://en.wikipedia.org/wiki/Active_Object),
[Balking pattern](https://en.wikipedia.org/wiki/Balking_pattern),
[Barrier](https://en.wikipedia.org/wiki/Barrier_\(computer_science\)),
[Double-checked locking](https://en.wikipedia.org/wiki/Double-checked_locking),
[Guarded suspension](https://en.wikipedia.org/wiki/Guarded_suspension),
[Leaders/followers pattern](https://java-design-patterns.com/patterns/leader-followers/),
[Monitor Object](https://en.wikipedia.org/wiki/Monitor_\(synchronization\)),
[Nuclear computation](https://en.wikipedia.org/wiki/Nuclear_computation),
[Reactor pattern](https://en.wikipedia.org/wiki/Reactor_pattern),
[Readers write lock pattern](https://en.wikipedia.org/wiki/Read_write_lock_pattern),
[Scheduler pattern](https://en.wikipedia.org/wiki/Read_write_lock_pattern),
[Thread pool pattern](https://en.wikipedia.org/wiki/Thread_pool_pattern),
[Thread-local storage](https://en.wikipedia.org/wiki/Thread-local_storage))

Також існує інша група шаблонів проєктування, що отримала назву [GRASP](https://uk.wikipedia.org/wiki/GRASP) — General Responsibility Assignment Software Patterns. Опис цих шаблонів наводить Craig Larman у своїй книзі «Applying UML and Patterns»:

- Інформаційний експерт (Information Expert)
- Творець примірників класу (Creator)
- Низька зв'язаність (Low Coupling)
- Високе зчеплення (High Cohesion)
- Контролер (Controller)
- Поліморфізм (Polymorphism)
- Штучний (Pure Fabrication)
- Перенаправлення (Indirection)
- Стійкий до змін (Protected Variations)

Шаблони GRASP формулюють найбільш базові принципи розподілу обов'язків між типами.

**6. Які знаєте алгоритми сортування?**

Відомі алгоритми сортування:

За час O(n^2):

- [Сортування вибором](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B2%D0%B8%D0%B1%D0%BE%D1%80%D0%BE%D0%BC) — (Selection sort) — пошук найменшого або найбільшого елемента і переміщення його в початок або кінець впорядкованого списку.
- [Сортування вставкою](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%BE%D1%8E) (включенням, Insertion sort) — визначаємо місце, де поточний елемент повинен знаходитися в упорядкованому списку, і вставляємо його туди.
- [Сортування обміном](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BE%D0%B1%D0%BC%D1%96%D0%BD%D0%BE%D0%BC) (сортування бульбашкою, Bubble sort) — для кожної пари індексів проводиться обмін, якщо елементи розташовані не по порядку.
- Сортування методом бінарної вставки

За час O(n log n):

- [Плавне сортування](https://uk.wikipedia.org/wiki/%D0%9F%D0%BB%D0%B0%D0%B2%D0%BD%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) (Smoothsort)
- [Пірамідальне сортування](https://uk.wikipedia.org/wiki/%D0%9F%D1%96%D1%80%D0%B0%D0%BC%D1%96%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
- [Швидке сортування](https://uk.wikipedia.org/wiki/%D0%A8%D0%B2%D0%B8%D0%B4%D0%BA%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)
- [Сортування злиттям](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%BB%D0%B8%D1%82%D1%82%D1%8F%D0%BC)
- [Timsort](https://uk.wikipedia.org/wiki/Timsort)

За час O(n):

- [Сортування підрахунком](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BF%D1%96%D0%B4%D1%80%D0%B0%D1%85%D1%83%D0%BD%D0%BA%D0%BE%D0%BC)
- [Сортування за розрядами](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0_%D1%80%D0%BE%D0%B7%D1%80%D1%8F%D0%B4%D0%B0%D0%BC%D0%B8)
- [Сортування комірками](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BA%D0%BE%D0%BC%D1%96%D1%80%D0%BA%D0%B0%D0%BC%D0%B8)

За час O(n log^2 n):

- [Сортування злиттям модифіковане](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7%D0%BB%D0%B8%D1%82%D1%82%D1%8F%D0%BC_%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D1%96%D0%BA%D0%BE%D0%B2%D0%B0%D0%BD%D0%B5)
- [Сортування Шелла](https://uk.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%A8%D0%B5%D0%BB%D0%BB%D0%B0)

За час O(n n!):

- Сортування перестановкою
- [Випадкове сортування](https://uk.wikipedia.org/wiki/%D0%92%D0%B8%D0%BF%D0%B0%D0%B4%D0%BA%D0%BE%D0%B2%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)

**7. Що таке Big-O notation?**

Big-O (Нотація Ландау) — поширена математична нотація для формального запису асимптотичної поведінки функцій. Це міра того, як швидко буде сповільнюватись робота коду з ростом кількості вхідних даних.

**8. Які відмінності між unit-тестом та інтеграційним тестом?**

Модульний тест — це метод тестування, за допомогою якого тестуються окремі одиниці вихідного коду, щоб визначити, чи готові вони до використання. Це допомагає зменшити вартість виправлення помилок, оскільки помилки виявляються на ранніх фазах життєвого циклу розробки.

Це свого роду тестування White Box; його можна виконати в будь-який час; не перевіряє, чи правильно код працює із зовнішніми залежностями; зазвичай його виконує розробник; знайти помилки легко; обслуговування є дешевим.

Інтеграційний тест — це техніка тестування програмного забезпечення, коли окремі блоки програми об'єднуються та перевіряються як група. Тестові заглушки та тестові драйвери використовуються для сприяння інтеграційному тестуванню.

Це свого роду тестування «чорної скриньки»; зазвичай проводиться після модульного тестування та перед тестуванням системи; звертає увагу на інтеграцію між модулями; перевіряє, чи правильно код працює із зовнішніми залежностями; зазвичай його виконує тестова група; знайти помилки складно; обслуговування є дорогим.

**9. Що таке mock і для чого його використовують?**

Mock Object (Макет об'єкта) у об'єктно-орієнтованому програмуванні — це об'єкт, що імітує поведінку справжнього об'єкту контрольованими способами, тобто, реалізує інтерфейс справжнього об'єкту, але не має власної реальної функціональності. Програміст зазвичай створює макет об'єкта для тестування поведінки інших об'єктів.

Корисні, коли реальний об'єкт недоцільно або неможливо використати в модульному тесті, наприклад коли об'єкт:

- надає недетерміновані результати (наприклад, час або температуру);
- є сценарії, які важко створити або відтворити (наприклад, помилка в мережі);
- повільно працює (наприклад, повна база даних, яка повинна бути ініціалізована до початку тестування);
- ще не існує або може змінити поведінку;
- повинен включати в себе інформацію і методи виключно для цілей тестування (а не для реального використання).

**10. Що таке SDLC? Які етапи й навіщо вони потрібні?**

SDLC (Software development lifecycle, Життєвий цикл розробки програмного забезпечення) — це повний процес розробки програмного рішення від ідеї до створення, розгортання та обслуговування.

Це детальний і визначений план етапів, який розробники використовують для планування, створення, тестування, розгортання та підтримки програмного рішення і який допомагає створювати якісне програмне забезпечення, що відповідає вимогам клієнтів і завершується в рамках оцінки витрат і встановлених часових рамок.

Зазвичай він включає сім етапів:

1. Requirement Analysis (Аналіз вимог) — документуються функціональні та нефункціональні вимоги, створюється специфікація програмного забезпечення.
2. Planning (Планування) — вирішуються питання, як буде виконуватися розробка, хто буде виконувати завдання, які витрати.
3. Architectural Design (Дизайн системи) — визначаються елементи системи, рівень безпеки, процес обробки та збереження інформації, технології, які будуть використовуватися.
4. Software Development (Розробка) — на цьому етапі починає писатися код.
5. Testing (Тестування) — тестування та виправлення знайдених дефектів.
6. Deployment (Розгортання) — надання програмного забезпечення кінцевим користувачам.
7. Maintenance (Експлуатація та обслуговування) — технічна підтримка продукту, зворотній зв’язок з користувачами.

**11. Що таке SOLID?**

SOLID — це абревіатура, складена з перших літер п'яти базових принципів об'єктно-орієнтованого програмування та дизайну і запропонована Робертом Мартіном у статті 2000 року Design Principles and Design Patterns:

- **S**RP, Single responsibility principle ([Принцип єдиного обов'язку](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%94%D0%B4%D0%B8%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%BE%D0%B2%27%D1%8F%D0%B7%D0%BA%D1%83)): кожен об'єкт має виконувати лише один обов'язок.
- **O**CP, Open/closed principle ([Принцип відкритості/закритості](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B2%D1%96%D0%B4%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96/%D0%B7%D0%B0%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96)): програмні сутності повинні бути відкритими для розширення, але закритими для змін. Тобто, має бути спосіб змінювати поведінку програмних модулів без потреби змінювати їхній вихідний код (наприклад, через механізм динамічного або статичного поліморфізму).
- **L**SP, Liskov substitution principle ([Принцип підстановки Лісков](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D1%96%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%9B%D1%96%D1%81%D0%BA%D0%BE%D0%B2)): об'єкти в програмі можуть бути заміненими їхніми нащадками без зміни коду програми.
- **I**SP, Interface segregation principle ([Принцип розділення інтерфейсу](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%80%D0%BE%D0%B7%D0%B4%D1%96%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F_%D1%96%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%83)): багато спеціалізованих інтерфейсів краще за один універсальний. Інтерфейс може бути поділений на спеціалізовані ще на стадії проєктування, заради майбутньої гнучкості програмних компонентів.
- **D**IP, Dependency inversion principle ([Принцип інверсії залежностей](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%96%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D1%96%D1%97_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)): залежності всередині системи будуються на основі абстракцій, що не повинні залежати від деталей; навпаки, деталі мають залежати від абстракцій. Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.

Принципи SOLID використовують для дизайну та розробки таких програмних систем, які, з великою ймовірністю, зможуть тривалий час розвиватися, розширятися і підтримуватися.

**12. Що таке MVC?**

Модель–вигляд/представлення–контролер (MVC, Model-view-controller) — архітектурний шаблон, який використовується під час проєктування та розробки програмного забезпечення.

Цей шаблон передбачає поділ системи на три взаємопов'язані частини: модель даних, вигляд (інтерфейс користувача) та модуль керування.

![MVC](https://upload.wikimedia.org/wikipedia/uk/thumb/d/d0/%D0%94%D1%96%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%B2%D0%B7%D0%B0%D1%94%D0%BC%D0%BE%D0%B4%D1%96%D1%97_%D0%BC%D1%96%D0%B6_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%83_MVC.png/400px-%D0%94%D1%96%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%B2%D0%B7%D0%B0%D1%94%D0%BC%D0%BE%D0%B4%D1%96%D1%97_%D0%BC%D1%96%D0%B6_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%83_MVC.png "MVC")

Застосовується для відокремлення даних (моделі) від інтерфейсу користувача (вигляду) так, щоб зміни інтерфейсу користувача мінімально впливали на роботу з даними, а зміни в моделі даних могли здійснюватися без змін інтерфейсу користувача, що створює гнучкий дизайн програмного забезпечення, який повинен полегшувати подальші зміни чи розширення програм, а також надавати можливість повторного використання окремих компонентів програми.

Крім того використання цього шаблону у великих системах сприяє впорядкованості їхньої структури і робить їх більш зрозумілими за рахунок зменшення складності.

**13. Що таке DBMS? Яка різниця між СУБД та базою даних?**

DBMS (Database Management System, Система управління базами даних, СУБД) — набір взаємопов'язаних даних (база даних) і програм для доступу до цих даних. Надає можливості створення, збереження, оновлення та пошуку інформації в базах даних з контролем доступу до даних.

База даних — сукупність даних, організованих відповідно до концепції, яка описує характеристику цих даних і взаємозв'язки між їх елементами. В загальному випадку база даних містить схеми, таблиці, подання, збережені процедури та інші об'єкти. Дані у базі організовують відповідно до моделі організації даних. Таким чином, сучасна база даних, крім самих даних, містить їх опис та може містити засоби для їх обробки.

**14. Які бувають типи баз даних?**

[Типи баз даних](https://dou.ua/lenta/articles/types-of-databases/):

- Прості типи баз даних
  - Текстові файли (csv-файли, ini-файли)

      Інформація збирається в простих за структурою файлах різних форматів. Для поділу полів застосовують пробіли, табуляцію, коми, крапку з комою та двокрапку.

      Такі бази легко використовувати — для роботи із файлами вистачить звичайного текстового редактора. Зручно працювати з елементами, що передбачають конфігурацію: обліковими даними, налаштуваннями під’єднання до віддалених серверів та пристроїв, портами тощо.

      Однак у таких базах важко встановити зв’язок між компонентами даних. Крім того, вони підходять не для всіх типів інформації.
  - Ієрархічні бази даних (організація файлових систем, DNS та LDAP-з’єднання)

      Між збереженими об’єктами встановлюються зв’язки. Об’єкти поділяються на «пращурів» (основні класи чи категорії об’єктів) та «нащадків» (примірники цих класів чи категорій). При цьому кожен «нащадок» може мати не більше ніж одного «пращура». Графічним втіленням такої бази даних є деревоподібна структура.

      Відносини між об’єктами реалізовані як фізичні покажчики. Наприклад, у файловій системі шлях до папки або файлу будується з імен кореневих та вкладених каталогів. Ще однією особливістю є моделювання відносин вкладеності та підпорядкованості.

      Але ієрархічна організація не передбачає зв’язку «багато-до-багатьох», через що система зберігання даних досить обмежена — забезпечує повільний доступ до сегментів даних нижніх рівнів ієрархії та орієнтується суто на певні типи запитів.
  - Мережеві бази даних (IDMS)

      Технологія розширює функціональність ієрархічного підходу за допомогою моделювання складних відносин між об’єктами. Тут «нащадки» можуть мати більше, ніж одного «пращура», проте обмеження ієрархічного підходу зберігаються.

      Подаються не деревом, а загальним графом (сукупністю двох кінцевих множин).
- Реляційні бази даних (MySQL, MariaDB, PostgreSQL, SQLite)

    Дані формуються у таблиці з рядків та стовпців. У рядках наводяться відомості про об’єкти (значення властивостей), а стовпці є властивостями об’єктів (поля).

    Складні відносини об’єктів у реляційних БД моделюються за допомогою зовнішніх ключів — посилань на інші таблиці. Це дає змогу підходити до питання проєктування бази даних із позицій нормалізації — мінімізації надмірності при описі властивостей об’єктів.

    Запити в реляційних базах даних формують за допомогою структурованої мови SQL. Вона дозволяє робити вибірки, проводити агрегації та угруповання, змінювати та видаляти дані, модифікувати структуру БД (створювати таблиці, поля), керувати доступом користувачів до тих чи інших операцій тощо.
- Нереляційні бази даних
  - Документоорієнтовані (MongoDB, RethinkDB, CouchDB, DocumentDB)

      Дані зберігаються в структурованих форматах — XML, JSON, BSON. При цьому зберігається адресний доступ до даних за ключем. Вміст документа може мати різний набір властивостей.

      Ці бази даних добре підходять для швидкої розробки систем та сервісів, що працюють з по-різному структурованими даними. Вони легко масштабуються та змінюють структуру за потреби.
  - Ключ-значення (DynamoDB, Redis, Riak, LevelDB, Memcached)

      Дані зберігаються як словник, де покажчиком є ключ. Можливе зберігання та обробка різних за типом і змістом даних.

      Крім того, вони мають високу швидкість доступу даних завдяки адресному зберіганню.

      Такі бази даних легко масштабувати. Можна створити правила шардування (практика розділення рядків однієї таблиці на кілька різних таблиць) за певними ключами — наприклад, сесії користувачів різних сайтів зберігаються у різних сегментах БД.

      Оскільки підхід не передбачає жорсткої типізації та структуризації даних, контроль їхньої валідності, а також найменування ключів залишаються на відповідальності розробника.
  - Графові (Neo4J, JanusGraph, Dgraph, OrientDB)

      Призначені для моделювання складних відносин за допомогою теорії графів, де зв’язками виступають ребра графа, а самі об’єкти — це вузли чи вершини.

      Такий підхід може стати в пригоді під час аналізу профілів користувачів соціальних мереж. Один користувач підписаний на оновлення іншого, інший підписаний на певну спільноту і так далі.

      Також технологія може використовуватися для аналізу економічної активності контрагентів для виявлення різних схем шахрайства. Наприклад, можна відстежити використання певних рахунків, карт чи реквізитів контрагентів у різних операціях.

      Особливістю є висока продуктивність, оскільки обхід ребер і вершин значно швидший за аналіз безлічі зовнішніх і внутрішніх таблиць в реляційних БД.
  - Стовпчикові/колонкові (Cassandra, HBase, ClickHouse)

      Записи в таких базах зберігаються не рядками, а стовпцями (колонками). Замість таблиць тут використовуються колонкові сімейства. Вони містять ключі, які вказують на формат рядка запису інформації про об’єкт. Кожен рядок має свій набір властивостей, що дозволяє зберігати у межах однієї родини по-різному структуровані дані.

      Технологію активно використовують при побудові аналітичних систем та сервісів, що працюють з великими обсягами даних.

      З групуванням властивостей колонок при запиті індексується менший обсяг даних, що забезпечує високу швидкість його виконання.

      БД мають широкі можливості масштабування та модифікації структури — при додаванні нових колонок не доведеться їх жорстко формалізувати, як у випадку з реляційними базами.
  - Часових рядів (OpenTSDB, Prometheus, InfluxDB, TimescaleDB)

      Можна використовувати для відстеження історичної динаміки за низкою показників. Дані групуються за часовими мітками. Частіше орієнтовані на запис, ніж на побудову складних аналітичних запитів.

      Особливістю є те, що можливо обробляти постійний потік вхідних даних.

      Продуктивність залежить від обсягу інформації, що надходить, і кількості метрик, що відстежуються.
  - NewSQL (MemSQL, VoltDB, Spanner)

      Компроміс між масштабованістю та узгодженістю за збереження реляційного підходу.

      Особливостями є широкі можливості масштабування та велика продуктивність і доступність даних. Однак є високі вимоги до апаратних ресурсів розробників.

      Застосування має сенс за умови розробки продукту, який можна характеризувати як високонавантажену систему.
  - Багатомодельні (ArangoDB)

      Поєднують у собі кілька підходів до організації даних одночасно.

      Це дає функціональне розмаїття під час розробки систем з їх використанням, можливість в одному запиті працювати з даними, що є у різних типах баз, не порушуючи при цьому узгодженості, широкі можливості масштабування за допомогою легкої інтеграції нових моделей баз даних у чинну інфраструктуру проєкту.

**15. Що таке Docker?**

[Docker](https://uk.wikipedia.org/wiki/Docker) — інструментарій для управління ізольованими Linux-контейнерами, який доповнює інструментарій LXC більш високорівневим API, що дозволяє керувати контейнерами на рівні ізоляції окремих процесів.

Зокрема, Docker дозволяє не переймаючись вмістом контейнера запускати довільні процеси в режимі ізоляції і потім переносити і клонувати сформовані для даних процесів контейнери на інші сервери, беручи на себе всю роботу зі створення, обслуговування і підтримки контейнерів.

### Бази даних

**16. Опишіть ACID-властивості реляційних баз даних.**

[ACID](https://uk.wikipedia.org/wiki/ACID) (Atomicity, Consistency, Isolation, Durability) (атомарність, узгодженість, ізольованість, довговічність) — це набір властивостей, що гарантують надійну роботу бази даних. В контексті баз даних, послідовність операцій з базою даних, яка задовольняє властивостям ACID, можна розглядати як одну логічну операцію над даними. Така послідовність операцій називається транзакцією.

**Атомарність** гарантує, що жодна транзакція не буде виконана частково. Будуть або виконані всі операції, що беруть участь у транзакції, або не виконано жодної. Якщо протягом роботи однієї з операцій виникне помилка і операцію буде відхилено, то будуть відхилені також усі інші зміни, здійснені в межах транзакції.

**Узгодженість** гарантує перебування системи у несуперечливому стані до початку дії транзакції і по її завершенню. При цьому вона може перебувати в неузгодженому стані протягом виконання транзакції, проте ця неузгодженість не буде видимою за межами транзакції завдяки іншим властивостям — атомарності та ізольованості.

**Ізольованість** означає, що жодні проміжні зміни не будуть видимі за межами транзакції аж до її завершення. Питання ізоляції стає актуальним при одночасній роботі багатьох транзакцій з тими самими даними. За цією вимогою, якщо дві транзакції намагатимуться змінити одні й ті самі дані, то одну з них буде відхилено або призупинено до завершення другої

**Довговічність** гарантує, що незалежно від інших проблем після відновлення працездатності системи результати завершених транзакцій будуть збережені. Іншими словами, якщо користувач отримав повідомлення про успішне завершення транзакції, то він може бути впевнений, що дані будуть збережені та відновлені у випадку збоїв.

**17. Є таблиця в реляційній БД зі 100 тисячами рядків. SELECT-запит з такої таблиці триває час *t*. Як зміниться час запиту, якщо кількість рядків буде один мільйон? Які є варіанти, залежно від запиту/таблиці?**

Час виконання SELECT-запиту залежить від кількості рядків у таблиці, структури таблиці, наявності індексів та складності запиту. Варіанти оптимізації запитів можуть включати використання індексів, вибірку конкретних полів, уникнення використання функцій агрегування, наприклад, COUNT або AVG, та роботу з кешем запитів.

**18. Для чого використовують індекси в базах даних і завдяки чому (яким структурам даних) вони працюють?**

[Індекс](https://uk.wikipedia.org/wiki/%D0%86%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%96_%D0%B1%D0%B0%D0%B7%D0%B8_%D0%B4%D0%B0%D0%BD%D0%B8%D1%85) — це об'єкт бази даних, створений з метою підвищення ефективності виконання запитів. Таблиці в базі даних можуть мати велику кількість рядків, які зберігаються у довільному порядку, і їх пошук за заданим значенням шляхом послідовного перегляду таблиці рядок за рядком може займати багато часу. Індекс формується зі значень одного чи кількох стовпчиків таблиці і вказівників на відповідні рядки таблиці і, таким чином, дозволяє знаходити потрібний рядок за заданим значенням. Прискорення роботи з використанням індексів досягається в першу чергу за рахунок того, що індекс має структуру, що оптимізована для пошуку.

Індекси фізично можуть бути реалізовані різними структурами. Найчастіше вживані [двійкові дерева](https://uk.wikipedia.org/wiki/%D0%91%D1%96%D0%BD%D0%B0%D1%80%D0%BD%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) і [хеш-таблиці](https://uk.wikipedia.org/wiki/%D0%93%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8F).

**19. З якими NoSQL-базами даних працювали? Які їхні переваги над реляційними базами?**

Redis — це NoSQL-база даних, яка дозволяє зберігати дані у форматі ключ-значення у швидкодіючому оперативному кеші, підтримує широкий спектр структур даних, включаючи списки, множини, хеші та сортовані множини.

NoSQL-бази даних порівняно з реляційними базами даних мають високу продуктивність та швидкий доступ до даних завдяки використанню спрощеної моделі даних та оптимізованої архітектури, зазвичай працюють на дешевшому обладнанні, що може знизити загальні витрати на обслуговування бази даних, дозволяють легко масштабувати базу даних горизонтально, тобто додавати нові сервери, щоб збільшити її продуктивність, що забезпечує високу доступність та масштабованість даних, зазвичай забезпечують гнучкішу модель даних, що дозволяє зберігати та обробляти різнорідні дані без необхідності використовувати строгу схему даних, нереляційні дані, такі як графи, ключ-значення та документи, що дозволяє використовувати їх для широкого спектру завдань та застосувань.

### Go

**20. На вашу думку, у чому перевага Go перед іншими мовами?**

Висока продуктивність компільованих мов з легкістю написання коду, швидкістю розробки і захищеністю від помилок, властивих скриптовим мовам, вбудовані засоби для паралельних обчислень, багатониткове програмування та ефективна робота на багатоядерних системах, засоби віддаленого керування пакунками, швидке компілювання під різні платформи, навіть на застарілому обладнанні.

**21. Що таке горутини й навіщо вони?**

Горутина - це легковажний потік виконання, який запускається з допомогою ключового слова go і працює у контексті основної програми. Горутини дозволяють створювати багатопоточні програми зі спільною пам'яттю, при цьому не потрібно явно створювати або керувати потоками виконання, як у більшості інших мов програмування.

Основною перевагою горутин є ефективність роботи з багатопоточністю. Вони забезпечують легкий та швидкий доступ до спільної пам'яті та можуть бути запущені та зупинені відносно дешево, забезпечують розподілення завдань на різні потоки, що дозволяє підвищувати швидкодію програм, простоту роботи з асинхронними операціями.

**22. Що таке GOROOT і GOPATH?**

GOROOT і GOPATH це змінні середовища, які використовуються в інструментах командного рядка Go.

GOROOT — вказує на шлях до кореневої директорії Go. В цій директорії зазвичай міститься встановлена версія Go, а також інші важливі файли і бібліотеки.

GOPATH — вказує на шлях до робочої директорії Go. У цій директорії зберігаються ваші проекти Go, а також всі залежності (бібліотеки), які ви використовуєте для розробки проекту.

Одна з особливостей Go — це те, що вона має вбудований менеджер залежностей, який дозволяє легко керувати залежностями вашого проекту. При цьому, всі залежності зазвичай зберігаються в папці GOPATH/pkg/mod.

**23. Які типи даних використовуються в Go?**

У мові програмування Go доступні наступні типи даних:

Базові типи:

``bool``: логічний тип даних, має два значення — ``true`` і ``false``.

Numeric types: включають в себе цілі числа (``int8, int16, int32, int64, uint8, uint16, uint32, uint64, uintptr``), число з плаваючою точкою (``float32, float64``) і комплексні числа (``complex64, complex128``).

``string``: відповідає текстовим рядкам.

Складені типи:

Масиви (``array``): фіксований розмір послідовності однотипних елементів.

Слайси (``slice``): динамічний масив, може змінювати розмір під час виконання програми.

Карти (``map``): набір пар ключ-значення, де кожен ключ унікальний.

Структури (``struct``): колекція різнотипних полів, що можуть мати власні імена.

Інтерфейси (``interface``): тип, що описує набір методів, які має реалізувати будь-який конкретний тип даних.

Особливі типи:

Функції (``func``): блок коду, який можна викликати з іншого місця в програмі.

Вказівники (pointers): змінна, що містить адресу в пам'яті іншої змінної.

Спеціальні типи:

Пустий тип (empty type): тип без значень, використовується в окремих випадках.

alias type: новий тип, який створюється на основі існуючого, з використанням ключового слова ``type``.

**24. Що робить функція ``init()``? Наведіть приклади, де її варто використовувати. Наведіть приклади, коли варто уникати.**

Функція ``init()`` є спеціальною функцією, яка автоматично викликається системою перед запуском програми і зазвичай використовується для виконання початкових налаштувань, ініціалізації глобальних змінних, підключення до баз даних або інших сервісів, встановлення рівня журналювання тощо.

Функція ``init()`` може бути визначена в будь-якому пакеті, і викликатися в порядку, визначеному системою. Наприклад, якщо ми маємо пакет з декількома файлами, то ``init()`` викликається в порядку їх компіляції. Якщо у пакеті є кілька функцій ``init()``, то вони виконуються в порядку їх оголошення.

Використання функції ``init()`` може викликати непередбачуване поведінку, якщо код пакету викликається відповідно до порядку завантаження модулів. Також, якщо використання функції ``init()`` призводить до створення глобальних змінних, то може виникнути проблема з гонками даних.

Виклик залежних від зовнішніх ресурсів функцій у ``init()`` може призвести до непередбачуваної поведінки програми в разі недоступності цих ресурсів.

**25. Поясніть різницю між помилкою і панікою.**

Помилки — це значення спеціального типу error, яке повертається з функцій, щоб повідомити про помилку в процесі виконання програми. Використання помилок дає можливість гнучко та зрозуміло обробляти помилки в програмі та продовжувати її роботу незалежно від того, чи виникли помилки.

Паніки — це неперехоплювані помилки, що виникають в результаті недопустимого стану програми. Вони можуть бути викликані за допомогою вбудованої функції ``panic()`` або виникати автоматично при неперехопленні помилки, наприклад, вихід за межі межі масиву або невірний доступ до пам'яті. Після виникнення паніки виконання програми припиняється, а стек викликів функцій розгортається (unwinding), поки не буде знайдений відповідний блок обробки паніки (recover), який може відновити виконання програми або повернути результат паніки.

Отже, основна різниця між помилкою та панікою полягає в тому, що помилки є оброблюваними, тоді як паніки неперехоплювані. Для використання панік повинні бути дійсно критичними помилками, коли немає можливості продовжити виконання програми.

**26. Як відловлювати паніки?**

Для відловлювання панік (помилок виконання) використовують функцію ``recover()``, яка повертає значення, що було передане до паніки, і зупиняє її подальше поширення.

Для використання ``recover()`` необхідно помістити її в блок ``defer``. Якщо в процесі виконання буде викликана паніка, то керування буде передано в блок ``defer`` і там можна використати ``recover()`` для обробки паніки.

Якщо ``recover()`` було викликано не в межах блоку ``defer``, то функція поверне ``nil``.

```
func main() {
    defer func() {
        if err := recover(); err != nil {
            log.Println("Panic occurred:", err)
        }
    }()

    // Some code that may panic
}
```

**27. Як отримати теперішній час?**

Для отримання поточного часу використовується функція ``time.Now()``, яка повертає значення типу ``time.Time``.

```
package main

import (
    "fmt"
    "time"
)

func main() {
    now := time.Now()
    fmt.Println(now)
}
```

**28. Що таке iota?**

``iota`` — це змінна-лічильник, що використовується для генерації послідовності цілих чисел в Go. Ці числа можуть використовуватись для ініціалізації констант та для інших цілей.

```
package main

import "fmt"

func main() {
	const (
		a = iota // 0
		b = iota // 1
		c = iota // 2
	)

	fmt.Println(a, b, c)

	const (
		d = iota // 0
		e        // 1
		f        // 2
	)

	fmt.Println(d, e, f)
}
```

**29. Яка різниця між слайсом і масивом?**

Масив — це набір елементів певного типу даних з фіксованим розміром, який встановлюється під час компіляції програми. Кількість елементів масиву не можна змінити під час виконання програми.

Слайс — це динамічно змінюваний набір елементів певного типу даних. Слайс не має фіксованого розміру, його можна динамічно збільшувати або зменшувати за допомогою функцій ``append()`` та ``copy()``. Слайс є посиланням на підмасив масиву.

Отже, головна різниця між масивом та слайсом полягає в тому, що масив має фіксований розмір, тоді як розмір слайсу може змінюватися під час виконання програми.

**30. З яких частин складається змінна типу slice?**

Слайс містить 3 поля: початок слайсу, довжину слайсу та його максимальну ємність.

**31. Як працює append?**

Функція ``append()`` використовується для додавання елементів до слайсу. Спочатку вона перевіряє ємність (capacity) слайсу, яка описує, скільки місця зарезервовано в масиві, на якому базується цей слайс.

Якщо поточна довжина слайсу менша за його ємність, функція append просто додає елемент до слайсу на наступній позиції.

Якщо поточна довжина слайсу досягла максимальної ємності, функція ``append()`` збільшує ємність масиву за допомогою алгоритму подвоєння масиву, копіює всі елементи в новий масив з більшою ємністю та додає новий елемент в кінець слайсу.

Функція append завжди повертає новий слайс.

**32. Що таке len і capacity в slice?**

len — це фактична кількість елементів, які знаходяться в slice.

capacity — це кількість елементів, яку може містити slice без зміни його розміру.

**33. Що таке пакети?**

Пакети є основним механізмом організації коду. Пакет — це колекція файлів з кодом, які можуть містити функції, типи, константи та інші елементи програми. Кожен пакет має унікальне ім'я та повинен бути оголошений на початку кожного файлу за допомогою ключового слова package.

Пакети дозволяють відокремити функціональність коду на незалежні модулі, які можуть бути повторно використані в інших програмах. Імпортування пакетів дозволяє використовувати функції, типи та інші елементи програми, які були оголошені у цих пакетах.

**34. Що таке інтерфейси і як вони працюють?**

Інтерфейс визначає набір методів, які повинен реалізувати тип даних, щоб задовольнити цей інтерфейс. Інтерфейси дозволяють створювати загальність між різними типами даних та реалізаціями, які різні за своєю природою та розширювати функціональність програмного коду, не змінюючи сам код, що його використовує.

Один тип даних може реалізувати кілька інтерфейсів, і більше одного типу даних можуть реалізувати той самий інтерфейс. Коли оголошується змінна типу інтерфейсу, вона може приймати значення будь-якого типу, який реалізує цей інтерфейс.

```
type Shape interface {
    Area() float64
}

type Circle struct {
    x, y, r float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.r * c.r
}
```

**35. Для чого потрібні інтерфейси в Golang?**

Завдяки інтерфейсам реалізуються:

- Поліморфізм — можливість використання однієї змінної для зберігання різних типів даних, які реалізують спільний інтерфейс.
- Функції можуть приймати аргументи типу інтерфейсу, що дозволяє писати більш загальні та універсальні функції (LSP в SOLID).
- Інтерфейси дають можливість замінити реалізацію певної функціональності в майбутньому без зміни коду, який використовує цю функціональність (OCP в SOLID).

**36. Що таке тип даних string?**

Тип даних ``string`` є вбудованим типом, що представляє послідовність символів Unicode.

Це незмінний тип, тобто один раз створений рядок не можна змінювати. Для редагування потрібно створити новий рядок, до якого можна додавати або від нього віднімати символи.

**37. Чим відрізняються лапки в Go (подвійні, одинарні, зворотні): ``""``,``''``, ``\`\```?**

"" — це подвійні лапки, вони використовуються для оголошення рядка (string). В рядку можна використовувати спеціальні послідовності символів, такі як \n для переносу рядка на новий рядок, або \t для вставки табуляції. Також в рядках можна використовувати знак долара $ для вставки значення змінної в рядок.

'' — це одинарні лапки, вони використовуються для оголошення символу (rune). Символ може бути будь-яким, але він має бути представлений лише одним символом, і символ відображається в ASCII-кодуванні.

\`\` — це зворотні лапки, вони використовуються для оголошення рядка, який може містити динамічно створювані значення змінних. В зворотних лапках можна використовувати спеціальні послідовності символів, такі як \n та \t, а також можна вставляти значення змінних з використанням знака долара $ та дужок {}.

**38. Що таке rune?**

``rune`` є аліасом для типу ``int32`` , який представляє символи Юнікод у рядках.

**39. Чи може змінна типу string приймати nil-значення?**

Ні

**40. Чи можна повернути з функції кілька значень?**

Функція може повертати будь-яку кількість результатів.

**41. Що відбувається під час конкатенації рядків?**

Конкатенація рядків в Go виконується за допомогою операції +. Під час конкатенації двох рядків відбувається створення нового рядка, який складається з об'єднання першого та другого рядків.

Під час створення нового рядка розмір пам'яті, який буде зайнятий під новий рядок, визначається як сума розмірів обох рядків. Після того, як створюється новий рядок, дані зі старих рядків копіюються в новий рядок.

**42. Як ефективно склеїти кілька рядків?**

Конкатенація рядків може бути досить затратною операцією, особливо якщо рядки містять велику кількість символів. Для об'єднання більшої кількості рядків рекомендується використовувати пакет ``strings``.

Метод ``strings.Join`` дозволяє ефективно склеїти кілька рядків.

```
strings.Join([]string{"Hello", "world!"}, " ")
```

Також використовують тип ``strings.Builder``.

```
var builder strings.Builder
builder.WriteString("Hello ")
builder.WriteString("world!")
result := builder.String()
fmt.Println(result)
```

**43. Як записати в файл?**

```
package main

import (
    "os"
)

func main() {
    // Відкриття файлу для запису
    file, err := os.OpenFile("output.txt", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    // Запис рядка в файл
    str := "Hello, world!\n"
    _, err = file.WriteString(str)
    if err != nil {
        panic(err)
    }
}
```

**44. Що таке структура?**

Структура — це тип даних, який дозволяє групувати дані різних типів в один об'єкт та дозволяють описувати складні користувацькі типи даних.

```
type Person struct {
    name    string
    age     int
    address string
}
```

Структури можуть бути ініціалізовані за допомогою літералів.

```
p := Person{
    name:    "John",
    age:     30,
    address: "123 Main St",
}
```

**45. Що буде, якщо викликати ``log.Fatal``?**

Виклик функції ``log.Fatal`` виводить повідомлення про помилку та завершує виконання програми з ненульовим кодом виходу. Це еквівалентно послідовному виклику функцій ``log.Print`` та ``os.Exit(1)``.

Якщо викликати ``log.Fatal`` у горутині, то програма не зупиниться повністю, оскільки горутини не блокують вихід програми. Замість цього, буде виведено повідомлення про помилку, а програма продовжить виконання інших горутин.

**46. Поясніть різницю між конкурентністю і паралельністю?**

Конкурентність означає можливість виконання кількох задач одночасно в одному процесі. Для досягнення конкурентності використовуються горутини, які дозволяють виконувати функції асинхронно, не блокуючи основний потік виконання.

Паралелізм означає виконання кількох задач одночасно в різних процесах або на різних ядрах процесора. Це дає можливість отримати значно більшу швидкість обробки завдань за рахунок використання багатопоточної обробки.

Паралелізму можна досягти за допомогою пакету ``sync``, який містить різні типи блокування та інші засоби для координації одночасної роботи горутин. Також, для паралельної обробки можна використовувати пакет ``runtime``, який дозволяє налаштувати кількість потоків виконання, які використовуються для обробки даних.

**47. Як оголосити відкладений виклик?**

Відкладення виклику функції до завершення поточної функції здійснюється за допомогою ключового слова defer.

```
file, err := os.Open("filename.txt")
if err != nil {
    log.Fatal(err)
}
defer file.Close() // Відкладення виклику функції file.Close()

// Код, що працює з файлом
```

**48. Що таке канал? Які типи каналів ви знаєте? Для чого вони потрібні?**

Канал — це механізм для передачі даних між горутинами. Канали дозволяють безпечно обмінюватися даними між горутинами без блокування або залежності від спільної пам'яті.

Існують два типи каналів: небуферизовані і буферизовані.

Небуферизовані канали — це канали з нульовою ємністю, тобто передача даних по такому каналу заблокує відправника до того моменту, коли отримувач не готовий прийняти дані.

``ch := make(chan int) // Небуферизований канал``

Буферизовані канали мають ємність, і передача даних по них не блокує відправника до того моменту, коли ємність каналу не буде заповнена.

``ch := make(chan int, 10) // Буферизований канал з розміром буфера 10``

Канали дозволяють забезпечити безпечний доступ до спільних даних в конкурентному середовищі. Крім того, канали використовуються для координації і синхронізації роботи горутин.

**49. Яка різниця між буферизованим і небуферизованим каналами?**

У небуферизованому каналі значення мають бути прочитані з каналу негайно після їх запису в канал.

Небуферизований канал гарантує синхронізацію між двома горутинами, бо передача значення здійснюється негайно, однак може спричинити блокування, якщо горутина, яка намагається записати дані у канал, заблокована, тому що немає горутини, яка б читала дані з цього каналу.

У буферизованому каналі передача значень здійснюється асинхронно. Значення можуть бути записані в канал, поки інша горутина зчитує значення з цього каналу. Це дозволяє уникнути блокування та знижує ризик виникнення гонок за даними.

Однак, якщо розмір буфера заповнено, то горутина, яка намагається записати дані у канал, буде заблокована до того часу, поки з каналу не буде зчитано якесь значення.

**50. Що буде, якщо читати із закритого каналу? Що буде, якщо писати у закритий канал?**

Відправник може закрити канал, щоб вказати, що більше значень не буде відправлено. Тільки відправник повинен закривати канал, а не отримувач.

Операція зчитування з закритого каналу буде заблокована, а програма буде чекати, доки дані не з'являться у каналі або доки програму не буде прервано з помилкою, оскільки закритий канал вже не має жодних даних, які можна прочитати, тому операція зчитування заблокована.

Отримувач може перевірити, чи був канал закритий.

``v, ok := <-ch``

Спроба записати у закритий канал призведе до паніки, оскільки закритий канал не може більше приймати дані. Програма отримає помилку "Send on closed channel".

Цикл ``for i := range c`` отримує значення з каналу поки він не буде закритий.

**51. Як перевірити, що змінна типу map має збережене значення для певного ключа?**

```
_, ok := myMap[key]
if ok {
    // ключ знайдено
} else {
    // ключ не знайдено
}
```

**52. Які стандартні env-змінні в Go?**

У Go немає стандартних env-змінних, які визначаються самою мовою. Однак, деякі додатки та бібліотеки Go можуть використовувати свої env-змінні. Деякі з них використовуються у широкому спектрі додатків, створених на Go, включаючи:

GOPATH — шлях до директорії, в якій зберігаються всі Go-проекти та їх залежності.

GOROOT — шлях до директорії, в якій встановлений Go SDK.

GOBIN — шлях до директорії, в яку будуть встановлені виконувані файли з пакетів Go.

GOOS та GOARCH — інформація про цільову платформу, для якої будується додаток.

Ці змінні можна використовувати в програмі Go, щоб отримувати доступ до значень з оточення. Для цього можна використовувати пакет ``os`` та функцію ``Getenv()``. Наприклад, для отримання значення змінної GOPATH:

```
import "os"

func main() {
    gopath := os.Getenv("GOPATH")
    fmt.Println("GOPATH is set to:", gopath)
}
```

**53. Яка різниця між value та pointer receiver?**

Отримувач значення отримує копію змінної, з якою він працює. Це означає, що будь-які зміни, які він вносить, залишаться тільки у копії, а не в оригінальній змінній.

Отримувач вказівника отримує вказівник на змінну, з якою він працює. Це означає, що будь-які зміни, які він вносить, будуть відображені в оригінальній змінній.

**54. Як зробити type assertion?**

Type assertion — це спосіб перевірити, чи зберігає інтерфейсова змінна значення вказаного типу.

```
var i interface{} = 5
value, ok := i.(int)
if ok {
    fmt.Println(value, "is an integer")
} else {
    fmt.Println("value is not an integer")
}
```

**55. Як та навіщо робити type assertion?**

type assertion використовується для перетворення змінної інтерфейсного типу на змінну конкретного типу, щоб отримати доступ до його методів та властивостей.

**56. Як написати benchmark?**

В Go існує вбудований пакет ``testing``, який дозволяє писати тести, в тому числі й бенчмарки.

Щоб написати бенчмарк, необхідно:

Створити файл з суфіксом ``_test.go``, наприклад, ``example_test.go``.

В файлі створити функцію з сигнатурою ``func BenchmarkXxx(b *testing.B)``, де ``Xxx`` — це назва функції, яку ви хочете протестувати. В тілі цієї функції треба написати код, який виконує операцію, яку ви хочете протестувати.

Використовуйте метод ``b.N`` для того, щоб визначити, скільки разів запускати ваш код. ``b.N`` — це кількість ітерацій, які буде виконано під час бенчмаркування.

Запустіть бенчмарк, використовуючи команду ``go test -bench=.``, де . означає поточний каталог.
Ось приклад функції, яку ми хочемо протестувати:

```
func Add(a, b int) int {
    return a + b
}
```

Ось приклад бенчмарку для цієї функції:

```
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(1, 2)
    }
}
```

В цьому прикладі ми запускаємо функцію ``Add`` з аргументами ``1`` та ``2`` ``b.N`` разів. Результатом буде середнє значення часу виконання цієї операції на одну ітерацію.

**57. В якому порядку виконуються кейси в select?**

Умови вибору (cases) в select обробляються в тому порядку, в якому вони були написані. Якщо декілька умов можуть бути виконані одночасно, select обирає одну з них випадковим чином. Якщо жодна з умов не виконується і присутній блок default, то виконується блок default.

### Практичні завдання

**58. Реалізувати алгоритм двійкового пошуку елемента у слайсі.**

```
package main

import "fmt"

func binarySearch(arr []int, key int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := low + (high-low)/2
        if arr[mid] == key {
            return mid
        } else if arr[mid] > key {
            high = mid - 1
        } else {
            low = mid + 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 3, 5, 7, 9, 11, 13}
    key := 7
    result := binarySearch(arr, key)
    if result == -1 {
        fmt.Printf("Елемент %d не знайдено у слайсі\n", key)
    } else {
        fmt.Printf("Елемент %d знайдено у позиції %d\n", key, result)
    }
}
```

**59. Є [код](https://play.golang.org/p/a-JIesxdCQ7). Що виведеться на екран? Що потрібно зробити, щоб побачити запропонований висновок Foo1 і Foo2?**

```
// start
// end

package main

import (
	"fmt"
)

func main() {
	fmt.Println("start")
	c := make(chan int)
	go Foo1(c)
	go Foo2(c)
	fmt.Println("end")
	<-c
	c <- 1
}

func Foo1(c chan int) {
	fmt.Println("foo1 begin")
	c <- 1
	fmt.Println("foo1 end")
}

func Foo2(c chan int) {
	fmt.Println("foo2 begin")
	<-c
	fmt.Println("foo2 end")
}
```

**60. Є [код](https://play.golang.org/p/6CiZvQp7r3t). Що виведеться на екран? Як вивести на екран літери?**

```
// 0 1 2

package main

import (
	"fmt"
)

func main() {
	arr := []string{"a", "b", "c"}

	for _, x := range arr {
		fmt.Println(x)
	}
}
```

**61. Поміняйте місцями значення двох змінних без тимчасової допоміжної змінної.**

```
package main

import "fmt"

func main() {
	a := 1
	b := 2
	fmt.Printf("a: %d, b: %d\n", a, b)
	a, b = b, a
	fmt.Printf("a: %d, b: %d\n", a, b)
}
```

**62. Оберніть slice у зворотному порядку.**

```
package main

import (
	"fmt"
)

func reverse(s []int) []int {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
	return s
}

func main() {
	s := []int{1, 2, 3, 4, 5}
	fmt.Println(s) // [1 2 3 4 5]
	s = reverse(s)
	fmt.Println(s) // [5 4 3 2 1]
}
```

**63. Перемістіть усі zero values у кінець масиву.**

```
package main

import (
	"fmt"
)

func moveZeroes(nums []int) {
	z := 0
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			nums[i], nums[z] = nums[z], nums[i]
			z++
		}
	}
}

func main() {
	nums := []int{0, 1, 0, 3, 12}
	moveZeroes(nums)
	fmt.Println(nums) // [1 3 12 0 0]
}
```

## Middle

### Software engineering

**1. У чому переваги та недоліки використання protobuf у порівнянні з JSON?**

Protocol Buffers (protobuf) та JSON є двома різними форматами серіалізації даних, які мають свої переваги та недоліки залежно від контексту використання.

Переваги використання protobuf:

1. Компактність: protobuf використовує бінарний формат, що призводить до меншого обсягу даних порівняно з текстовим форматом JSON. Це особливо важливо при передачі великих обсягів даних по мережі або зберіганні на диску.
2. Швидкодія: protobuf зазвичай працює швидше при серіалізації та десеріалізації даних порівняно з JSON. Це особливо важливо при великих навантаженнях або в обчислювально вимогливих застосунках.
3. Статична типізація: protobuf має строго визначену схему даних, відповідно до визначення у файлі `.proto`. Це дозволяє забезпечити статичну типізацію та перевірку правильності даних, що сприяє надійності та допомагає у виявленні помилок.

Недоліки використання protobuf:

1. Нечитабельність: protobuf використовує бінарний формат, що робить його менш зрозумілим та складнішим для відладки та аналізу в порівнянні з текстовим форматом JSON.
2. Недостатня підтримка у мовах програмування: хоча protobuf підтримується у багатьох мовах програмування, в деяких мовах підтримка може бути обмеженою або неіснуючою. Це може бути обмеженням при інтеграції з існуючими системами або виборі мови програмування для проекту.

**2. Назвіть деякі з принципів 12-factor-app. Для чого використовують graceful shutdown?**

12-факторний підхід --- це набір принципів, які визначають кращі практики для розробки сучасних, масштабованих та легко підтримуваних додатків:

1. Кодова база знаходиться у контролі версій: використовуйте систему контролю версій для збереження та керування кодовою базою.

2. Залежності заявлені як окремі пакети: залежності програми повинні бути чітко оголошені та ізольовані у вигляді окремих пакетів, які можна легко встановлювати та оновлювати.

3. Конфігурація зберігається у зовнішньому середовищі: відокремлюйте конфігурацію від коду та зберігайте її у зовнішньому середовищі, щоб забезпечити гнучкість та легкість налаштування.

4. Зберігання стану відсутнє: додатки повинні бути безстандартними, а будь-який стан, необхідний для роботи додатку, повинен бути збережений у зовнішніх засобах, таких як база даних або служба зберігання.

5. Створення процесів за шаблоном: додатки повинні бути розбиті на окремі процеси, які можна горизонтально масштабувати та керувати незалежно.

6. Розмежування логіки за допомогою служб: логіка додатків повинна бути розмежована на окремі служби з чітким інтерфейсом та комунікацією між ними через стандартизовані протоколи.

7. Ізоляція ресурсів: кожній службі або компоненту слід надавати власні, ізольовані ресурси, такі як бази даних чи кеш-системи.

8. Масштабування горизонтально: додатки повинні бути легко масштабовані горизонтально, дозволяючи додавати більше екземплярів для розподіленого навантаження.

9. Логування як потік подій: логування повинно бути зроблене як потік подій, який може бути легко агрегований, промоніторений та проаналізований.

10. Адміністративні задачі виконуються через процеси: адміністративні задачі повинні виконуватися через окремі процеси, що дозволяє уникнути впливу на роботу основного додатку.

11. Робочі процеси одноразові: робочі процеси повинні бути одноразовими, без збереження стану між запусками та можливістю заміни їх при необхідності.

12. Розвиток, тестування та виробництво однакові: усі середовища розробки, тестування та виробництва повинні бути максимально схожими, щоб уникнути неочікуваних проблем.

Graceful shutdown (граціозне завершення) використовується для контрольованого та безпечного зупинення додатків. Під час граціозного завершення додаток закриває активні з'єднання, завершує обробку запитів та дозволяє завершити незавершені задачі перед вимкненням. Це важливо для забезпечення стійкості та надійності системи, а також для уникнення втрати даних або несподіваних побічних ефектів при зупиненні.

При граціозному завершенні, додаток може виконувати наступні кроки:

1. Закриття активних з'єднань: додаток може відправити сигнал на закриття активних з'єднань або завершити їх роботу, щоб не допустити нові запити.

2. Завершення обробки запитів: додаток може перестати приймати нові запити та дочекатися завершення обробки запитів, що вже були розпочаті.

3. Виконання необхідних завершальних дій: додаток може виконати будь-які необхідні завершальні дії, такі як збереження даних, очистка ресурсів або збереження стану перед закриттям.

**3. Що таке dependency injection? А dependency inversion?**

**Dependency Injection (DI)**, або ін'єкція залежності, є підходом до організації коду, в якому залежності об'єкту (тобто інші об'єкти або сервіси, які він використовує) передаються в нього зовні, замість того, щоб він сам їх створював. Це означає, що об'єкт несе відповідальність лише за свою основну функціональність, а залежності надаються ззовні.

Головна ідея DI полягає в тому, щоб зменшити зв'язаність між класами та покращити перевикористання коду. Замість того, щоб класи самостійно створювати та залежати від інших класів або сервісів, вони отримують ці залежності від зовнішнього джерела. Це може бути здійснено через конструктори, методи або інші механізми ін'єкцій.

Переваги використання DI:

1. Зменшення зв'язаності: DI допомагає знизити зв'язаність між класами, оскільки вони не прямо створюють та не залежать від своїх залежностей.

2. Покращене перевикористання коду: Завдяки DI код стає більш перевикористовуваним, оскільки залежності можна легко замінювати або модифікувати без необхідності зміни самого класу.

3. Тестування: DI полегшує тестування, оскільки залежності можуть бути легко замінені на мок-об'єкти або фейкові реалізації під час тестування.

4. Інверсія керування: DI допомагає виконувати принцип Інверсії керування (IoC), коли об'єкт не сам контролює свої залежності, а отримує їх ззовні.

Для впровадження DI в Go можна використовувати структури та інтерфейси, а також різні бібліотеки, такі як "google/wire" або "uber/dig".

**Dependency Inversion** є одним з принципів проектування програмного забезпечення, який входить до загального сімейства принципів Інверсії залежностей (Dependency Inversion Principle --- DIP). Він є частиною SOLID-принципів, які спрямовані на створення гнучких, зрозумілих та підтримуваних систем.

Засадничий принцип інверсії залежностей полягає в наступному:

1. Високорівневі модулі не повинні залежати від низькорівневих модулів. Обидва типи модулів повинні залежати від абстракцій.

2. Абстракції не повинні залежати від деталей. Деталі повинні залежати від абстракцій.

Це означає, що код повинен бути зорієнтований на використання абстрактних типів та інтерфейсів, замість прив'язки до конкретних реалізацій. Високорівневі модулі використовують абстракції, щоб взаємодіяти з низькорівневими модулями через ці абстракції, що дозволяє замінювати реалізації без необхідності змінювати високорівневий код.

Цей принцип дозволяє досягти великої гнучкості та розширюваності системи, зменшити зв'язаність між компонентами, сприяє втіленню принципу інверсії керування (Inversion of Control - IoC) та полегшує тестування коду, оскільки залежності можуть бути замінені на мок-об'єкти або фейкові реалізації під час тестування.

**4. У вас є ssh-доступ на Linux-сервер, де запущено вебсервер. З сервером періодично відбуваються незаплановані рестарти. Сервер записує логи у файли (розмір лог-файлу > 10 Mb). Які \*nix-команди ви можете використати, щоб проаналізувати проблему?**

Для аналізу проблеми з незапланованими рестартами сервера і перегляду лог-файлів можна використовувати наступні команди:

1. `tail`: Команда `tail` дозволяє переглядати останні рядки лог-файлу. Ви можете використовувати `tail` для відслідковування оновлень лог-файлу під час перезавантаження сервера. Наприклад, `tail -f logfile.txt` виведе нові рядки, які додаються до `logfile.txt`.

2. `grep`: Команда `grep` використовується для пошуку певних виразів у лог-файлі. Ви можете використати `grep` для виявлення певних повідомлень або помилок, які можуть бути пов'язані з незапланованими рестартами. Наприклад, `grep "error" logfile.txt` виведе всі рядки, що містять слово "error".

3. `dmesg`: Команда `dmesg` виводить системний журнал, який містить повідомлення про різні події та помилки ядра. Ви можете перевірити `dmesg` для пошуку повідомлень про незаплановані рестарти або помилки, які можуть бути пов'язані з проблемами сервера.

4. `df`: Команда `df` дозволяє перевірити стан файлової системи сервера, включаючи використання дискового простору. Перевірка доступного дискового простору може бути корисною, особливо якщо виснаження дискового простору може призводити до незапланованих рестартів.

5. `top` або `htop`: Команда `top` або `htop` виводить інформацію про процеси, що виконуються на сервері, разом з використанням ресурсів, таких як CPU та пам'ять. Ви можете використати ці команди для перевірки завантаженості системи під час незапланованих рестартів.

6. `systemctl`: Команда `systemctl` дозволяє керувати системними службами, такими як вебсервер. Ви можете перевірити стан служби, перезавантажити або перезапустити її. Наприклад, `systemctl status apache2` показує стан служби Apache.

7. `journalctl`: Команда `journalctl` дозволяє переглядати системний журнал, включаючи журнали служб. Використайте `journalctl -u <service-name>` для перегляду журналу конкретної служби, наприклад, `journalctl -u nginx` для журналу Nginx.

**5. Як працює TLS handshake?**

TLS (Transport Layer Security) handshake --- це процес встановлення безпечного з'єднання між клієнтом і сервером в рамках протоколу TLS/SSL. Він включає в себе кілька кроків для обміну ключами, встановлення параметрів безпеки та підтвердження ідентичності сторін.

Основні кроки TLS handshake:

1. Привітання (ClientHello і ServerHello): Клієнт і сервер обмінюються привітальними повідомленнями, включаючи версію TLS, списки підтримуваних шифрів, криптографічних параметрів та випадкових чисел.

2. Установка параметрів безпеки: Клієнт обирає найкращий спільний шифр та параметри безпеки зі списку, наданих сервером, і відправляє свої налаштування (ClientKeyExchange).

3. Аутентифікація сервера (Server Authentication): Сервер презентує свій цифровий сертифікат клієнту для підтвердження своєї ідентичності. Клієнт перевіряє цифровий сертифікат, використовуючи довірене центральне сертифікаційне або самозавідений сертифікат.

4. Обмін ключами (Key Exchange): Клієнт генерує передачу сесійного ключа, який зашифровує дані, а потім передає його серверу, зашифрованому публічним ключем сервера. Сервер використовує свій приватний ключ для розшифрування сесійного ключа.

5. Аутентифікація клієнта (Client Authentication) (необов'язково): Якщо сервер вимагає аутентифікацію клієнта, клієнт може представити свій цифровий сертифікат для перевірки сервером.

6. Генерація симетричного ключа: Клієнт і сервер незалежно генерують симетричний сесійний ключ на основі обмінених ідентифікаторів, параметрів і випадкових чисел.

7. Підтвердження (Finished): Клієнт і сервер обмінюються підтверджувальними повідомленнями, які підписуються за допомогою симетричного сесійного ключа. Це дозволяє переконатися, що обидві сторони мають правильний сесійний ключ і з'єднання зашифроване.

Після успішного TLS handshake клієнт і сервер мають встановлене безпечне з'єднання і можуть починати обмін даними, які будуть зашифровані та захищені від прослуховування та модифікації.

**6. Яка різниця між TCP та UDP? В якій ситуації UPD краще?**

**7. Розкажіть у найдрібніших деталях, що відбувається, коли клієнт посилає запит на сервер, а сервер цей запит отримує.**

**8. Що таке Clean Architecture? Наведіть приклад.**

**9. Що таке оперативна пам’ять?**

**10. Як різниця між stack та heap?**

Stack — це область пам'яті, яка використовується для зберігання локальних змінних та функцій, параметрів та адрес повернення. Стекова пам'ять резервується під час створення потоку виконання програми.

Heap — це область пам'яті, яка використовується для зберігання глобальних змінних, а також для динамічної алокування пам'яті під об'єкти з великою тривалістю життя або невідомим розміром.

**11. Для чого потрібні Docker та Kubernetes?**

**12. Розкажіть про абстракції Kubernetes, з якими працювали?**

**13. Що таке Pod? Як він влаштований?**

**14. Розкажіть про Data structures: stack, queue, linked list, trie, balanced tree.**

### Бази даних

**15. Які шляхи пошуку повільних SELECT-запитів у RDBMS? Які способи пришвидшення таких запитів?**

**16. Що таке нормальні форми бази даних?**

**17. Що таке індекси? Які їхні недоліки?**

**18. Які структури даних можуть використовуватися в індексах баз даних? Як вони працюють?**

**19. Яка різниця між foreign та primary key?**

**20. Поняття міграції у контексті баз даних. У чому переваги підходу з міграціями?**

**21. Що таке реплікація даних? Які варіанти реплікації існують для баз, з якими ви працювали?**

**22. Яка різниця між SQL і NoSQL?**

**23. Які типи NoSQL баз даних ви знаєте? Наведіть приклади. Яка між ними різниця?**

**24. Що таке колонкова БД? Переваги та недоліки.**

**25. Що таке документоорієнтована БД? Переваги та недоліки.**

**26. Розкажіть про роботу з key-value базами даних (бажано з власного досвіду).**

**27. З якими типами даних Redis у вас є практичний досвід? Назвіть приклади, коли їх доцільно використовувати.**

### Go

**28. Якими бібліотеками Go ви користувалися для доступу до RDBMS? Які у них позитивні та негативні сторони?**

**29. Для чого використовують Context? Які є варіанти скасовування контекстів?**

**30. Якими способами можна виключити (приховати) поля структури при JSON-серіалізації?**

**31. Назвіть примітиви пакету sync стандартної бібліотеки. Яке призначення та приклади застосування ``sync.WaitGroup``?**

**32. Яка різниця між Mutex та RWMutex?**

**33. Які є способи зупинити N горутин, запущених одночасно (наприклад, worker pool)?**

**34. Що таке замикання функцій?**

**35. Поясніть різницю між switch і select?**

**36. Які є способи дістати дані з JSON?**

**37. Як у Go реалізовані конструкції циклів?**

**38. Як влаштований тип map?**

**39. Який порядок перебору map?**

**40. Що таке серіалізація? Де вона застосовується?**

**41. Чи можна використовувати nil для ініціалізації змінної?**

**42. Чи можна задати місткість map? Чи можна отримати місткість map?**

**43. Як дізнатися кількість символів у рядку?**

**44. Що таке кодогенерація і для чого вона потрібна?**

**45. Чим відрізняється goroutine від OS thread?**

**46. Як і для чого використовують ``io.Reader`` і ``io.Writer``?**

**47. Як перетворити ``[]io.ReadWriter`` на ``[]io.Reader``?**

**48. Як вказати головній горутині очікувати завершення роботи всіх робочих горутин?**

**49. Чи завжди буде швидше передача Pointer як аргументу функції?**

**50. Що таке варіативна змінна функції? Як працювати з цією змінною?**

**51. Як працювати з пакетом internal?**

**52. Як працює імпорт через крапочку і чому це погана практика?**

**53. Як працює імпорт через підкреслення?**

**54. Що таке ``defer()``?**

**55. Як працювати з goto?**

**56. Що таке ``reflect.DeepEqual()`` і ``reflect.TypeOf()``?**

**57. Як розпарсити час?**

**58. Як порівняти дві дати?**

**59. Що таке вказівник і як з ним працювати?**

**60. Як перевірити, чи змінна імплементує інтерфейс?**

**61. Що таке embedding?**

**62. Опишіть кроки процесу тестування.**

**63. Як писати тести? Що таке табличні тести?**

**64. Що таке memory leak? Які є способи його виявлення? Як його позбутися?**

**65. Що таке race condition? Які є способи його виявлення? Як його позбутися?**

### Практичні завдання

**67. Реалізувати перевірку на слова на анаграму. Написати тест і бенчмарк. Оцінити складність розробленого алгоритму.**

**68. Є [код](https://play.golang.org/p/-3o2gp3enIG). Що виведеться на екран? Чому?**

**69. Є [код](https://play.golang.org/p/qwC_nJNFdEy). Чи можна передбачити, що виведеться на екран? Чому?**

**70. Реалізуйте Stack (LIFO).**

**71. Реалізуйте linked list.**

**72. Задача про суму підмножини (Subset Sum Problem). Дано: множина позитивних цілих чисел і значення sum. Визначте, чи існує підмножина даної множини з сумою, яка дорівнює значенню sum.**

```
Input: set [] = {3, 34, 4, 12, 5, 2}, sum = 9
Output: True
```

## Senior

### Software engineering

**1. Що таке процес і потік? Як вони пов’язані між собою? Чи мають різні процеси чи потоки доступу до однієї області пам’яті?**

**2. Які інструменти зазвичай використовують для збору метрик і логів? Як працює Prometheus?**

**3. Як працює docker під капотом?**

**4. Як працює load balancer під капотом?**

**5. Для чого потрібні черги?**

**6. Що таке CQRS?**

**7. Які архітектури програмного забезпечення ви знаєте?**

**8. Яка різниця між мікросервісами та монолітом? Які є переваги та недоліки?**

**9. Як побудувати міжсервісну транзакцію?**

**10. Що таке розподілені транзакції? Як реалізувати?**

**11. Які проблеми вирішує патерн Saga?**

**12. Як реалізувати аутентифікацію в мікросервісній архітектурі?**

**13. Що таке Event Sourcing?**

**14. Сформулюйте CAP-теорему.**

**15. Розкажіть про Raft Consensus Algorithm.**

**16. У чому різниця між імперативною і декларативною парадигмою програмування? Наведіть приклади мов.**

### Бази даних

**17. Для чого потрібні графові бази даних?**

**18. Якщо точкові дані прив’язані до часу, які бази даних варто використовувати для збереження цих даних?**

**19. Що таке Materialized View? У чому відмінність від звичайного View?**

**20. Що таке ACID? Прокоментуйте, як ACID реалізований в PostgreSQL.**

**21. Яка різниця між BASE та ACID?**

**22. Назвіть рівні ізоляції транзакцій?**

**23. Досвід оптимізації бази. Які інструменти використовували?**

**24. Що таке шардинг? Які види є?**

**25. Як працює master-slave реплікація?**

**26. Як працюють індекси? Як вибрати індекси в таблицях?**

**27. Розкажіть про optimistic та pessimistic locking.**

### Go

**28. За що відповідає змінна GOMAXPROCS? Яке її значення за замовчуванням?**

**29. Хто відповідає за планування горутин? Розкажіть про алгоритм роботи планувальника. Навіщо він потрібен, якщо вже й так є системні потоки?**

**30. Розкажіть про алгоритм роботи garbage collector. Mark and sweep, Reference counting та оптимізації алгоритму в мові Go. Що таке stop the world?**

**31. Які види багатозадачності ви знаєте? Який з них використовують у Go?**

**32. Для чого потрібна рефлексія? У чому різниця між рефлексією та кодогенерацією?**

**33. У чому різниця між value та reference типом? Назвіть декілька прикладів у мові Go.**

**34. Як зупинити горутину?**

**35. Як в Go реалізується спадкування?**

**36. Що таке lvalue і rvalue?**

**37. Яке у slice zero value?**

**38. Як вбудувати стандартний профайлер у свій застосунок?**

**39. Що таке map-reduce? Як його реалізувати в Go?**

**40. Як в Go працює префіксний інкремент/декремент?**

**41. Що буде, якщо перетворити в JSON-об’єкт, структура якого містить поля з малими літерами в назвах?**

**42. Як перервати for/switch або for/select?**

**43. Як можна оптимізувати виконання великої кількості послідовних операцій читання або запису?**

**44. Чи можна викликати метод у вказівника (pointer) на структуру, якщо він дорівнює nil?**

**45. Що буде при спробі запису в закритий канал?**

**46. Що таке взаємне блокування (deadlock)?**

**47. У чому особливість nil-каналів?**

**48. У яких випадках варто використовувати м’ютекси, а не канали, та навпаки?**

**49. Що таке білд-теги?**

**50. Як реалізувати LRU cache?**

**51. Що таке SSA-представлення?**

**52. Що ви знаєте про роботу з плагінами на Go?**

**53. Що таке аліаси типів?**

**54. Що таке падінги в структурах і на що вони впливають?**

**55. Що таке escape-аналіз?**

**56. Яка різниця між стеком і купою?**

**57. Що нам дає пакет unsafe?**

**58. Чи можна змінити певний символ у рядку? А за допомогою пакета unsafe?**

**59. Як працювати з рефлексією і що ми можемо з нею зробити?**

**60. Як під капотом виглядають слайси й мапи?**

**61. Як працювати з ``copy()``?**

**62. Як працювати з sync.Pool і [sync.Map](https://l.facebook.com/l.php?u=http%3A%2F%2Fsync.Map%2F%3Ffbclid%3DIwAR0IRDk_3BRFwVxRcE0uuDiDriYFAB-vmhE1kPgf-v4pAu-WVSAqs3RquBg&h=AT2u89KulT3y4yWcAEDgMTLEKrYnDjKrjAxEX6ycQ9dAB2T-Bzbvcph3lXrW-c1-uwxT24bKzuE1Y_rBdl3iNBYs8njT3uo8X3QJ4nqGhY7md3GKjNHy0lxtdvjTdtZtB2FIwy_scz0)? Які підводні камені вони мають?**

**63. Розкажіть про канкаренсі-патерни в Go.**

**64. Як у Go реалізована арифметика вказівників?***

### Практичні завдання

**65. Побудувати архітектуру бекенду для оренди самокатів типу Kiwi чи Bolt. Які мікросервіси будуть? Які мови та інструменти? Який клауд-провайдер? Що варто використати як інфраструктуру? Які бази даних та шини повідомлень?**

**66. Уявімо, що ви провідний розробник на проєкті, як би ви розподілили ролі в команді із 5 людей для найефективнішої роботи?**

**67. Є [код](https://play.golang.org/p/QSajZuzP-GN). Чому ``err! = nil``?**

**68. Вам дають ssh на сервер і просять полагодити вебзастосунок, який «впав». Інформації про сервер і сервіси немає. Які команди ви будете використовувати, щоб зібрати інформацію, знайти та усунути проблему?**

**69. Реалізуйте двійкову структуру даних дерева пошуку в Go.**

**70. Знайдіть максимальну суму шляху в трикутнику. (Подано числа у формі трикутника, починаючи з верхньої частини трикутника і рухаючись до сусідніх чисел у рядку внизу, знаходимо максимальну загальну кількість зверху вниз.)**
